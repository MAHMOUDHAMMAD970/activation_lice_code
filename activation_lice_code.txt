 //******************************************************************************
// *****************************************************************************
// Section: Included Files  
// 3.5 inch TFT LCD Screen Module 3.3V/5V ILI9486/ILI9488 Ultra HD 320X480 *****
// *****************************************************************************
// *****************************************************************************

// <send_SPI_settings> has been changed! for attenuation
// 

#include <stddef.h>                     // Defines NULL
#include <stdbool.h>                    // Defines true
#include <stdlib.h>                     // Defines EXIT_FAILURE
#include "system/common/sys_module.h"   // SYS function prototypes
#include "driver/spi/static/src/drv_spi_static_local.h"
#include "app.h"

#include <xc.h>
#include <stdint.h>
#include <math.h>
#include <flash.h>
#include <proc/p32mx795f512l.h>
#include "Constants.h"


#define LEFT 0
#define RIGHT 9999
#define CENTER 9998

#define PORTRAIT 0
#define LANDSCAPE 1

#define NOTINUSE    255

//*********************************
// COLORS
//*********************************
// VGA color palette
#define VGA_BLACK   0x0000
#define VGA_WHITE   0xFFFF
#define VGA_RED     0xF800
#define VGA_GREEN   0x0400
#define VGA_BLUE    0x001F
#define VGA_SILVER    0xC618
#define VGA_GRAY    0x8410
#define VGA_MAROON  0x8000
#define VGA_YELLOW  0xFFE0
#define VGA_OLIVE   0x8400
#define VGA_LIME    0x07E0
#define VGA_AQUA    0x07FF
#define VGA_TEAL    0x0410
#define VGA_NAVY    0x0010
#define VGA_FUCHSIA   0xF81F
#define VGA_PURPLE    0x8010
#define VGA_TRANSPARENT 0xFFFFFFFF
typedef uint8_t byte; //#define byte "unsigned char" //In C++
#define word uint16_t
#define swap(type, i, j) {type t = i; i = j; j = t;}
#define fontbyte(x) cfont.font[x]  
#define regtype volatile uint32_t
#define regsize uint16_t
#define bitmapdatatype unsigned short*
#define pgm_read_word(x)(*((short *)x))
#define pgm_read_byte(x)(*((char *)x))

#define PAGE_IN_USE_PWD 0xdeadbeef                  // password meaning a valid flash buffer is present
#define PAGE_IN_USE_INDEX (PAGE_WORDS-1)            // the password is at the last index of buffer
#define MAX_PROJECT 100       //EEPROM 0xFE


struct current_font {
    uint8_t* font;
    uint8_t x_size;
    uint8_t y_size;
    uint8_t offset;
    uint8_t numchars;
};

uint8_t getEEPROMdata[MAX_NUM_OF_BYTES] = {0};
uint8_t What_getEEPROMdata[MAX_NUM_OF_BYTES] = {0};
uint8_t W_Data[21];
unsigned char Adr_Arr[2];
//void WDRV_STUB_HardDelay(uint16_t delay_ms);
void delay_ms(int count);
void TFTU();
void InitLCD(byte orientation);
void clrScr();
void drawPixel(int x, int y);
void drawLine(int x1, int y1, int x2, int y2);
void fillScr_1(byte r, byte g, byte b);
void fillScr(word color);
void drawRect(int x1, int y1, int x2, int y2);
void drawRoundRect(int x1, int y1, int x2, int y2);
void fillRect(int x1, int y1, int x2, int y2);
void fillRoundRect(int x1, int y1, int x2, int y2);
void drawCircle(int x, int y, int radius);
void fillCircle(int x, int y, int radius);
void setColor_1(byte r, byte g, byte b);
void setColor(word color);
word getColor();
void setBackColor_1(byte r, byte g, byte b);
void setBackColor(uint32_t color);
word getBackColor();
void print_1(char *st, int x, int y, int deg);
void print(char st[], int x, int y, int deg);
void printNumI(long num, int x, int y, int length, char filler);
void printNumF(double num, byte dec, int x, int y, char divider, int length, char filler);
void setFont(uint8_t* font);
uint8_t* getFont();
uint8_t getFontXsize();
uint8_t getFontYsize();
void drawBitmap_1(int x, int y, int sx, int sy, unsigned short* data, int scale);
void drawBitmap(int x, int y, int sx, int sy, unsigned short* data, int deg, int rox, int roy);
void lcdOff();
void lcdOn();
void setContrast(char c);
int getDisplayXSize();
int getDisplayYSize();
void setBrightness(byte br);
void setDisplayPage(byte page);
void setWritePage(byte page);
void draw_battery();
void draw_Plug_bat();
 

byte fch, fcl, bch, bcl;
byte orient;
long disp_x_size, disp_y_size;
byte display_model, display_transfer_mode, display_serial_mode;
struct current_font cfont;
bool _transparent, Flag_SPI_Bat, Flag_SPI_USB;
uint8_t data_spi,channel, Transm_Power,YB_posX, YB_posY,YB_posY_s;                        // channel to be REMOVED
int8_t dBmPower[7];     // We do not need 16 bits (that's only in 4GHz because we were saving in Flash)
int YB_X1, YB_X2, YB_Y1, YB_Y2;
int YB_X1_s, YB_X2_s, YB_Y1_s, YB_Y2_s;
uint8_t dataOut[8], dataIn[8];
int Freq_IN[7];
char test_IN;     

int Frq_limit=40000;

void LCD_Writ_Bus(char VH, char VL);
void LCD_Write_COM(char VL);
void LCD_Write_DATA_1(char VH, char VL);
void LCD_Write_DATA(char VL);
void LCD_Write_COM_DATA(char com1, int dat1);
void LCD_Write_Bus_8(char VL);
void LCD_Write_DATA_8(char VL);
//void _hw_special_init();
void setPixel(word color);
void drawHLine(int x, int y, int l);
void drawVLine(int x, int y, int l);
void printChar(byte c, int x, int y);
void setXY(word x1, word y1, word x2, word y2);
void clrXY();
void rotateChar(byte c, int x, int y, int pos, int deg);
void _fast_fill_16(int ch, int cl, long pix);
void _convert_float(char *buf, double num, int width, byte prec);
void lcdOn();
void lcdOff();
void BackLight_On();
void BackLight_OFF();

//void PDRF_PLL_Activate(uint8_t channel);
//void PDN_Ampl_Activate(uint8_t channel);
void PDRF_PLL_DE_Activate(uint8_t channel);
//void PDN_Ampl_DE_Activate(uint8_t channel);
void send_SPI_settings(uint8_t channel_s, uint16_t Freq_IN_s, int8_t Power_s);
void LED_CHAN_Activate(uint8_t channel);
void LED_CHAN_DE_Activate(uint8_t channel);
uint8_t get_channel(void);
int get_dBmP(void);
uint8_t get_Tr_Power(void);
int get_Freq(void);
void activation_Set(void);
void Set_RF(void);
void STOP_RF(void);
void Save_New_Project(void);
void Save_Project(void);
uint8_t Run_Stop_Marker;

// Declare which fonts we will be using
extern uint8_t Arial_round_16x24[];
extern uint8_t SevenSegNumFont[];
extern uint8_t SmallFont[];
extern uint8_t arial_8x16[];
extern unsigned short Main_Screen_6[0x25800];       //!!! It has to be included in Source Files/app/  Combo_1

int clk_min,i_for;
int half_clk_sec;
char key_int, help_1; 
int edvx=33, edvy=61;
int x_pos, y_pos,x_pos_back,y_pos_back, projectNum,y_pos_prt, y_pos_SON; 
unsigned char Lat_ProjNum, Curr_ProjNum, True_ProjNum;
uint8_t char_count,i,show_scrn,show_scrn_set;
int Num_ret;
uint8_t Stack[6]; 

int i_test_flash, nxt_p_index, addr_Num, i_SON, All_OFF;
double Freq_D, mes_calc;

void test_RF_1();
void test_RF_2();
void Channels_In(void);
void Project_In(void); 
void Settings_In(void);
void Help_In(void);
void Set_Dev_inf(void);
void activation_screen(void);
void Mod_inf(void);
void Calibr(void);
void Keypad(void);
void Current_Show(void);
void Set_ON_OFF(void);
void SPI_Voltages(uint8_t Bat_USB);
void Lamda_Set(void);
uint8_t ONOFF_Chan[7];
uint8_t Collect; 
uint8_t Trans_ONOFF_Chan[7];
int attenuate[7];       // Used to be uint8_t
double cal_offset;
uint16_t Flash_Back[575];       // Back up Flash
uint16_t Bat1_ADC, Bat2_ADC, USB_ADC;
int Debug_index;
int Adc_in;
double Volt_Show;

char readBuffer[3];


unsigned char Get_True(unsigned char Enter_ProjNum);

void Calib(void);
void Turn_OFF(void);
bool dBmBool=true; 
uint8_t rx_byte;
uint8_t S_Data[6];
uint16_t Freq_Send;
bool Flag_Send_Freq;


void setup()           // Setup the LCD
{ 
    InitLCD(LANDSCAPE);
    delay_ms(120);
    setFont(Arial_round_16x24);  
    clrScr();
    delay_ms(1200);
    fillScr(VGA_PURPLE); // Fill Screen with colour
    delay_ms(100);
}

void loop() {
    int ego;
    //myGLCD.InitLCD();
    //delay_ms(50);
    //myGLCD.clrScr();
    //delay_ms(50);
    //myGLCD.fillScr(VGA_PURPLE);         // Fill Screen with color
    //myGLCD.setFont(Arial_round_16x24);
    //delay_ms(50);
    //myGLCD.setColor(VGA_PURPLE);        // Set color to Delete
    //delay_ms(50); 
    drawRect(0, 7, 460, 35);
    delay_ms(500);
    //delay_ms(3000);
    setColor(VGA_PURPLE); // Set color to Delete
    //chk = getColor(); // DEBUG REMOVE!!
    drawRect(0, 7, 460, 35);
    //delay_ms(1000);
    delay_ms(500);
    int edvx, edvy;
    edvx = 7;
    edvy = 35;
    for (ego = 0; ego < 11; ego++) {
        //LATCbits.LATC3=1;
        edvx = edvx + 26;
        edvy = edvy + 26;
        setColor(VGA_YELLOW); // Set color to all Draw, Fill and Print(letters)
        drawRect(0, edvx, 460, edvy);
        //delay_ms(4000);
        delay_ms(500);
        // LATCbits.LATC3=0;
        setColor(VGA_PURPLE); // Set color to Delete
        drawRect(0, edvx, 460, edvy);
        //delay_ms(1000); 
        delay_ms(500);
    }
    //  lcdOff();
    // myGLCD.setFont(SevenSegNumFont);
    //myGLCD.setColor(0, 255, 0); // Green Text
    // myGLCD.print("180 1 181", 300, 300, 180); // Hor,Vert,Rotate
    //  delay_ms(5000);
    //  lcdOn();
    //while (true) {};
    //delay_ms(5000);
}

void lcdOn() {
    LATGbits.LATG13 = 0; //CS
    LCD_Write_COM(0x29);
    LATGbits.LATG13 = 1; //CS
}

void lcdOff() {
    LATGbits.LATG13 = 0; //CS
    LCD_Write_COM(0x28);
    LATGbits.LATG13 = 1; //CS
}


// You can completely Remove this! Change it to void TFTU()
void TFTU() {
    disp_x_size = 319;              //  
    disp_y_size = 479;              // 
    display_transfer_mode = 16;     // 
    display_model = 28;
}

void LCD_Writ_Bus(char VH, char VL) {
    LATDCLR = 0x00FF;                 // Clears ALL bits of port D
    LATDSET = VL & 0x00FF;
    LATECLR = 0x00FF;
    LATESET = VH & 0x00FF;
    LATGbits.LATG12 = 0; //WR
    LATGbits.LATG12 = 1; //WR
}

void _fast_fill_16(int ch, int cl, long pix) {
    long blocks;
    int i;
    LATDCLR = 0x00FF;
    LATDSET = cl & 0x00FF;
    LATECLR = 0x00FF;
    LATESET = ch & 0x00FF;

    blocks = pix / 16;
    for (i = 0; i < blocks; i++) {
        LATGbits.LATG12 = 0;
        LATGbits.LATG12 = 1; //WR 1
        LATGbits.LATG12 = 0;
        LATGbits.LATG12 = 1; //WR 2
        LATGbits.LATG12 = 0;
        LATGbits.LATG12 = 1; //WR 3
        LATGbits.LATG12 = 0;
        LATGbits.LATG12 = 1; //WR 3
        LATGbits.LATG12 = 0;
        LATGbits.LATG12 = 1; //WR 4
        LATGbits.LATG12 = 0;
        LATGbits.LATG12 = 1; //WR 5
        LATGbits.LATG12 = 0;
        LATGbits.LATG12 = 1; //WR 6
        LATGbits.LATG12 = 0;
        LATGbits.LATG12 = 1; //WR 7
        LATGbits.LATG12 = 0;
        LATGbits.LATG12 = 1; //WR 8
        LATGbits.LATG12 = 0;
        LATGbits.LATG12 = 1; //WR 9
        LATGbits.LATG12 = 0;
        LATGbits.LATG12 = 1; //WR 10
        LATGbits.LATG12 = 0;
        LATGbits.LATG12 = 1; //WR 11
        LATGbits.LATG12 = 0;
        LATGbits.LATG12 = 1; //WR 12
        LATGbits.LATG12 = 0;
        LATGbits.LATG12 = 1; //WR 13
        LATGbits.LATG12 = 0;
        LATGbits.LATG12 = 1; //WR 14
        LATGbits.LATG12 = 0;
        LATGbits.LATG12 = 1; //WR 15
    }
    if ((pix % 16) != 0)
        for (i = 0; i < (pix % 16) + 1; i++) {
            LATGbits.LATG12 = 0;
            LATGbits.LATG12 = 1; //WR
        }
}

void LCD_Write_COM(char VL) {
    LATGbits.LATG14 = 0; // RS 
    LCD_Writ_Bus(0x00, VL);
}

void LCD_Write_DATA_1(char VH, char VL) {
    LATGbits.LATG14 = 1; // RS
    LCD_Writ_Bus(VH, VL);
}

void LCD_Write_DATA(char VL) {
    LATGbits.LATG14 = 1; // RS
    LCD_Writ_Bus(0x00, VL);
}

void LCD_Write_COM_DATA(char com1, int dat1) {
    LCD_Write_COM(com1);
    LCD_Write_DATA_1(dat1 >> 8, dat1);
}

void InitLCD(byte orientation) {
    lcdOn();
    orient = orientation;
    //TRISGbits.TRISG12 = 0; //  WR  
    //TRISGbits.TRISG13 = 0; //  CS
    //TRISGbits.TRISG14 = 0; //  RS
    //TRISAbits.TRISA9 = 0; //  RST
    //TRISE = 0xFF00; // (display_transfer_mode);
    //TRISD = 0xFF00; // Both for replacement

    LATAbits.LATA9 = 1; // RST  
    delay_ms(50);
    LATAbits.LATA9 = 0; //RST
    delay_ms(50);
    LATAbits.LATA9 = 1; //RST
    delay_ms(50);
    LATGbits.LATG13 = 0; //RST
    delay_ms(50);

    LCD_Write_COM(0x11); // Sleep OUT
    delay_ms(50);

    LCD_Write_COM(0xF2); // ?????
    LCD_Write_DATA(0x1C);
    LCD_Write_DATA(0xA3);
    LCD_Write_DATA(0x32);
    LCD_Write_DATA(0x02);
    LCD_Write_DATA(0xb2);
    LCD_Write_DATA(0x12);
    LCD_Write_DATA(0xFF);
    LCD_Write_DATA(0x12);
    LCD_Write_DATA(0x00);

    LCD_Write_COM(0xF1); // ?????
    LCD_Write_DATA(0x36);
    LCD_Write_DATA(0xA4);

    LCD_Write_COM(0xF8); // ?????
    LCD_Write_DATA(0x21);
    LCD_Write_DATA(0x04);

    LCD_Write_COM(0xF9); // ?????
    LCD_Write_DATA(0x00);
    LCD_Write_DATA(0x08);

    LCD_Write_COM(0xC0); // Power Control 1
    LCD_Write_DATA(0x0d);
    LCD_Write_DATA(0x0d);

    LCD_Write_COM(0xC1); // Power Control 2
    LCD_Write_DATA(0x43);
    LCD_Write_DATA(0x00);

    LCD_Write_COM(0xC2); // Power Control 3
    LCD_Write_DATA(0x00);

    LCD_Write_COM(0xC5); // VCOM Control
    LCD_Write_DATA(0x00);
    LCD_Write_DATA(0x48);

    LCD_Write_COM(0xB6); // Display Function Control
    LCD_Write_DATA(0x00);
    LCD_Write_DATA(0x42); // It was 0x22 I've changed it!! 0x42 = Rotate display 180 deg. !!! SEE HERE FOR SCREEN ROTATION
    LCD_Write_DATA(0x3B);

    LCD_Write_COM(0xE0); // PGAMCTRL (Positive Gamma Control)
    LCD_Write_DATA(0x0f);
    LCD_Write_DATA(0x24);
    LCD_Write_DATA(0x1c);
    LCD_Write_DATA(0x0a);
    LCD_Write_DATA(0x0f);
    LCD_Write_DATA(0x08);
    LCD_Write_DATA(0x43);
    LCD_Write_DATA(0x88);
    LCD_Write_DATA(0x32);
    LCD_Write_DATA(0x0f);
    LCD_Write_DATA(0x10);
    LCD_Write_DATA(0x06);
    LCD_Write_DATA(0x0f);
    LCD_Write_DATA(0x07);
    LCD_Write_DATA(0x00);

    LCD_Write_COM(0xE1); // NGAMCTRL (Negative Gamma Control)
    LCD_Write_DATA(0x0F);
    LCD_Write_DATA(0x38);
    LCD_Write_DATA(0x30);
    LCD_Write_DATA(0x09);
    LCD_Write_DATA(0x0f);
    LCD_Write_DATA(0x0f);
    LCD_Write_DATA(0x4e);
    LCD_Write_DATA(0x77);
    LCD_Write_DATA(0x3c);
    LCD_Write_DATA(0x07);
    LCD_Write_DATA(0x10);
    LCD_Write_DATA(0x05);
    LCD_Write_DATA(0x23);
    LCD_Write_DATA(0x1b);
    LCD_Write_DATA(0x00);

    LCD_Write_COM(0x20); // Display Inversion OFF
    LCD_Write_DATA(0x00); // C8    

    LCD_Write_COM(0x36); // Memory Access Control
    LCD_Write_DATA(0x0A);

    LCD_Write_COM(0x3A); // Interface Pixel Format
    LCD_Write_DATA(0x55);

    LCD_Write_COM(0x2A); // Column Address Set
    LCD_Write_DATA(0x00);
    LCD_Write_DATA(0x00);
    LCD_Write_DATA(0x01);
    LCD_Write_DATA(0xDF);

    LCD_Write_COM(0x002B); // Page Address Set
    LCD_Write_DATA(0x00);
    LCD_Write_DATA(0x00);
    LCD_Write_DATA(0x01);
    LCD_Write_DATA(0x3f);
    //delay_ms(50);
    LCD_Write_COM(0x0029); // Display ON
    LCD_Write_COM(0x002C); // Memory Write

    LATGbits.LATG13 = 1; // CS  
    setColor_1(255, 255, 255);
    setBackColor_1(0, 0, 0);
    cfont.font = 0;
    _transparent = false;
}

void setXY(word x1, word y1, word x2, word y2) {
    if (orient == LANDSCAPE) {
        swap(word, x1, y1);
        swap(word, x2, y2)
        y1 = disp_y_size - y1;
        y2 = disp_y_size - y2;
        swap(word, y1, y2)
    }
    LCD_Write_COM(0x2A);
    LCD_Write_DATA(x1 >> 8);
    LCD_Write_DATA(x1);
    LCD_Write_DATA(x2 >> 8);
    LCD_Write_DATA(x2);
    LCD_Write_COM(0x2B);
    LCD_Write_DATA(y1 >> 8);
    LCD_Write_DATA(y1);
    LCD_Write_DATA(y2 >> 8);
    LCD_Write_DATA(y2);
    LCD_Write_COM(0x2C);
}

void clrXY() {
    if (orient == PORTRAIT)
        setXY(0, 0, disp_x_size, disp_y_size);
    else
        setXY(0, 0, disp_y_size, disp_x_size);
}

void drawRect(int x1, int y1, int x2, int y2) {
    if (x1 > x2) {
        swap(int, x1, x2);
    }
    if (y1 > y2) {
        swap(int, y1, y2);
    }

    drawHLine(x1, y1, x2 - x1);
    drawHLine(x1, y2, x2 - x1);
    drawVLine(x1, y1, y2 - y1);
    drawVLine(x2, y1, y2 - y1);
}

void drawRoundRect(int x1, int y1, int x2, int y2) {
    if (x1 > x2) {
        swap(int, x1, x2);
    }
    if (y1 > y2) {
        swap(int, y1, y2);
    }
    if ((x2 - x1) > 4 && (y2 - y1) > 4) {
        drawPixel(x1 + 1, y1 + 1);
        drawPixel(x2 - 1, y1 + 1);
        drawPixel(x1 + 1, y2 - 1);
        drawPixel(x2 - 1, y2 - 1);
        drawHLine(x1 + 2, y1, x2 - x1 - 4);
        drawHLine(x1 + 2, y2, x2 - x1 - 4);
        drawVLine(x1, y1 + 2, y2 - y1 - 4);
        drawVLine(x2, y1 + 2, y2 - y1 - 4);
    }
}

void fillRect(int x1, int y1, int x2, int y2) {
    long mes;
    if (x1 > x2) {
        swap(int, x1, x2);
    }
    if (y1 > y2) {
        swap(int, y1, y2);
    }
    if (display_transfer_mode == 16) {
        LATGbits.LATG13 = 0; // CS 
        setXY(x1, y1, x2, y2);
        LATGbits.LATG14 = 1; // RS 
        mes = ((x2 - x1) + 1)*((y2 - y1) + 1);
        _fast_fill_16(fch, fcl, mes); // the long() remove!!!
        LATGbits.LATG13 = 1; // CS 
    }
}

void fillRoundRect(int x1, int y1, int x2, int y2) {
    int i;
    if (x1 > x2) {
        swap(int, x1, x2);
    }
    if (y1 > y2) {
        swap(int, y1, y2);
    }

    if ((x2 - x1) > 4 && (y2 - y1) > 4) {
        for (i = 0; i < ((y2 - y1) / 2) + 1; i++) {
            switch (i) {
                case 0:
                    drawHLine(x1 + 2, y1 + i, x2 - x1 - 4);
                    drawHLine(x1 + 2, y2 - i, x2 - x1 - 4);
                    break;
                case 1:
                    drawHLine(x1 + 1, y1 + i, x2 - x1 - 2);
                    drawHLine(x1 + 1, y2 - i, x2 - x1 - 2);
                    break;
                default:
                    drawHLine(x1, y1 + i, x2 - x1);
                    drawHLine(x1, y2 - i, x2 - x1);
            }
        }
    }
}

void drawCircle(int x, int y, int radius) {
    int f = 1 - radius;
    int ddF_x = 1;
    int ddF_y = -2 * radius;
    int x1 = 0;
    int y1 = radius;

    LATGbits.LATG13 = 0; // CS 
    setXY(x, y + radius, x, y + radius);
    LCD_Write_DATA_1(fch, fcl);
    setXY(x, y - radius, x, y - radius);
    LCD_Write_DATA_1(fch, fcl);
    setXY(x + radius, y, x + radius, y);
    LCD_Write_DATA_1(fch, fcl);
    setXY(x - radius, y, x - radius, y);
    LCD_Write_DATA_1(fch, fcl);

    while (x1 < y1) {
        if (f >= 0) {
            y1--;
            ddF_y += 2;
            f += ddF_y;
        }
        x1++;
        ddF_x += 2;
        f += ddF_x;
        setXY(x + x1, y + y1, x + x1, y + y1);
        LCD_Write_DATA_1(fch, fcl);
        setXY(x - x1, y + y1, x - x1, y + y1);
        LCD_Write_DATA_1(fch, fcl);
        setXY(x + x1, y - y1, x + x1, y - y1);
        LCD_Write_DATA_1(fch, fcl);
        setXY(x - x1, y - y1, x - x1, y - y1);
        LCD_Write_DATA_1(fch, fcl);
        setXY(x + y1, y + x1, x + y1, y + x1);
        LCD_Write_DATA_1(fch, fcl);
        setXY(x - y1, y + x1, x - y1, y + x1);
        LCD_Write_DATA_1(fch, fcl);
        setXY(x + y1, y - x1, x + y1, y - x1);
        LCD_Write_DATA_1(fch, fcl);
        setXY(x - y1, y - x1, x - y1, y - x1);
        LCD_Write_DATA_1(fch, fcl);
    }
    LATGbits.LATG13 = 1; // CS 
    clrXY();
}

void fillCircle(int x, int y, int radius) {
    int y1, x1;
    for (y1 = -radius; y1 <= 0; y1++)
        for (x1 = -radius; x1 <= 0; x1++)
            if (x1 * x1 + y1 * y1 <= radius * radius) {
                drawHLine(x + x1, y + y1, 2 * (-x1));
                drawHLine(x + x1, y - y1, 2 * (-x1));
                break;
            }
}

void clrScr() {
    long i;
    LATGbits.LATG13 = 0; // CS 
    clrXY();
    LATGbits.LATG14 = 1; // RS 
    _fast_fill_16(0, 0, ((disp_x_size + 1)*(disp_y_size + 1)));
    LATGbits.LATG13 = 1; // CS 
}

void fillScr_1(byte r, byte g, byte b) {
    word color = ((r & 248) << 8 | (g & 252) << 3 | (b & 248) >> 3);
    fillScr(color);
}

void fillScr(word color) {
    long i;
    char ch, cl;

    ch = color >> 8;
    cl = color & 0xFF;

    LATGbits.LATG13 = 0; // CS 
    clrXY();
    if (display_transfer_mode != 1)
        LATGbits.LATG14 = 1; // RS 
    if (display_transfer_mode == 16)
        _fast_fill_16(ch, cl, ((disp_x_size + 1)*(disp_y_size + 1)));
    LATGbits.LATG13 = 1; // CS 
}

void setColor_1(byte r, byte g, byte b) {
    fch = ((r & 248) | g >> 5);
    fcl = ((g & 28) << 3 | b >> 3);
}

void setColor(word color) {
    fch = color >> 8;
    fcl = color & 0xFF;
}

word getColor() {
    return (fch << 8) | fcl;
}

void setBackColor_1(byte r, byte g, byte b) {
    bch = ((r & 248) | g >> 5);
    bcl = ((g & 28) << 3 | b >> 3);
    _transparent = false;
}

void setBackColor(uint32_t color) {
    if (color == VGA_TRANSPARENT)
        _transparent = true;
    else {
        bch = color >> 8;
        bcl = color & 0xFF;
        _transparent = false;
    }
}

word getBackColor() {
    return (bch << 8) | bcl;
}

void setPixel(word color) {
    LCD_Write_DATA_1((color >> 8), (color & 0xFF)); // rrrrrggggggbbbbb
}

void drawPixel(int x, int y) {
    LATGbits.LATG13 = 0; // CS 
    setXY(x, y, x, y);
    setPixel((fch << 8) | fcl);
    LATGbits.LATG13 = 1; // CS 
    clrXY();
}

void drawLine(int x1, int y1, int x2, int y2) {
    if (y1 == y2)
        drawHLine(x1, y1, x2 - x1);
    else if (x1 == x2)
        drawVLine(x1, y1, y2 - y1);
    else {
        unsigned int dx = (x2 > x1 ? x2 - x1 : x1 - x2);
        short xstep = x2 > x1 ? 1 : -1;
        unsigned int dy = (y2 > y1 ? y2 - y1 : y1 - y2);
        short ystep = y2 > y1 ? 1 : -1;
        int col = x1, row = y1;

        LATGbits.LATG13 = 0; // CS 
        if (dx < dy) {
            int t = -(dy >> 1);
            while (true) {
                setXY(col, row, col, row);
                LCD_Write_DATA_1(fch, fcl);
                if (row == y2)
                    return;
                row += ystep;
                t += dx;
                if (t >= 0) {
                    col += xstep;
                    t -= dy;
                }
            }
        } else {
            int t = -(dx >> 1);
            while (true) {
                setXY(col, row, col, row);
                LCD_Write_DATA_1(fch, fcl);
                if (col == x2)
                    return;
                col += xstep;
                t += dy;
                if (t >= 0) {
                    row += ystep;
                    t -= dx;
                }
            }
        }
        LATGbits.LATG13 = 1; // CS 
    }
    clrXY();
}

void drawHLine(int x, int y, int l) {
    if (l < 0) {
        l = -l;
        x -= l;
    }
    LATGbits.LATG13 = 0; // CS 
    setXY(x, y, x + l, y);
    if (display_transfer_mode == 16) {
        LATGbits.LATG14 = 1; // RS 
        _fast_fill_16(fch, fcl, l);
    }
    LATGbits.LATG13 = 1; // CS 
    clrXY();
}

void drawVLine(int x, int y, int l) {
    if (l < 0) {
        l = -l;
        y -= l;
    }
    LATGbits.LATG13 = 0; // CS 
    setXY(x, y, x, y + l);
    if (display_transfer_mode == 16) {
        LATGbits.LATG14 = 1; // RS 
        _fast_fill_16(fch, fcl, l);
    }
    LATGbits.LATG13 = 1; // CS 
    clrXY();
}

void printChar(byte c, int x, int y) {
    byte i, ch;
    word j;
    word temp;
    int zz;

    LATGbits.LATG13 = 0; // CS

    if (!_transparent) {
        if (orient == PORTRAIT) {
            setXY(x, y, x + cfont.x_size - 1, y + cfont.y_size - 1);

            temp = ((c - cfont.offset)*((cfont.x_size / 8) * cfont.y_size)) + 4;
            for (j = 0; j < ((cfont.x_size / 8) * cfont.y_size); j++) {
                ch = pgm_read_byte(&cfont.font[temp]);
                for (i = 0; i < 8; i++) {
                    if ((ch & (1 << (7 - i))) != 0) {
                        setPixel((fch << 8) | fcl);
                    }
                    else {
                        setPixel((bch << 8) | bcl);
                    }
                }
                temp++;
            }
        } 
        else 
            {
            temp = ((c - cfont.offset)*((cfont.x_size / 8) * cfont.y_size)) + 4;

            for (j = 0; j < ((cfont.x_size / 8) * cfont.y_size); j += (cfont.x_size / 8)) {
                setXY(x, y + (j / (cfont.x_size / 8)), x + cfont.x_size - 1, y + (j / (cfont.x_size / 8)));
                for (zz = (cfont.x_size / 8) - 1; zz >= 0; zz--) {
                    ch = pgm_read_byte(&cfont.font[temp + zz]);
                    for (i = 0; i < 8; i++) {
                        if ((ch & (1 << i)) != 0) {
                            setPixel((fch << 8) | fcl);
                        }
                        else {
                            setPixel((bch << 8) | bcl);
                        }
                    }
                }
                temp += (cfont.x_size / 8);
            }
        }
    } else {
        temp = ((c - cfont.offset)*((cfont.x_size / 8) * cfont.y_size)) + 4;
        for (j = 0; j < cfont.y_size; j++) {
            for (zz = 0; zz < (cfont.x_size / 8); zz++) {
                ch = pgm_read_byte(&cfont.font[temp + zz]);
                for (i = 0; i < 8; i++) {

                    if ((ch & (1 << (7 - i))) != 0) {
                        setXY(x + i + (zz * 8), y + j, x + i + (zz * 8) + 1, y + j + 1);
                        setPixel((fch << 8) | fcl);
                    }
                }
            }
            temp += (cfont.x_size / 8);
        }
    }

    LATGbits.LATG13 = 1; // CS 
    clrXY();
}

void rotateChar(byte c, int x, int y, int pos, int deg) {
    byte i, j, ch;
    word temp;
    int newx, newy, zz;
    double radian, m_cos;
    radian = deg * 0.0175;

    LATGbits.LATG13 = 0; // CS 

    temp = ((c - cfont.offset)*((cfont.x_size / 8) * cfont.y_size)) + 4;
    for (j = 0; j < cfont.y_size; j++) {
        for (zz = 0; zz < (cfont.x_size / 8); zz++) {
            ch = pgm_read_byte(&cfont.font[temp + zz]);
            for (i = 0; i < 8; i++) {
                newx = x + (((i + (zz * 8)+(pos * cfont.x_size)) * cos(radian))-((j) * sin(radian)));
                newy = y + (((j) * cos(radian))+((i + (zz * 8)+(pos * cfont.x_size)) * sin(radian)));

                setXY(newx, newy, newx + 1, newy + 1);

                if ((ch & (1 << (7 - i))) != 0) {
                    setPixel((fch << 8) | fcl);
                }
                else {
                    if (!_transparent)
                        setPixel((bch << 8) | bcl);
                }
            }
        }
        temp += (cfont.x_size / 8);
    }
    LATGbits.LATG13 = 1; // CS 
    clrXY();
}

void print_1(char *st, int x, int y, int deg) {
    int stl, i;

    stl = strlen(st);

    if (orient == PORTRAIT) {
        if (x == RIGHT)
            x = (disp_x_size + 1)-(stl * cfont.x_size);
        if (x == CENTER)
            x = ((disp_x_size + 1)-(stl * cfont.x_size)) / 2;
    } else {
        if (x == RIGHT)
            x = (disp_y_size + 1)-(stl * cfont.x_size);
        if (x == CENTER)
            x = ((disp_y_size + 1)-(stl * cfont.x_size)) / 2;
    }

    for (i = 0; i < stl; i++)
        if (deg == 0)
            printChar(*st++, x + (i * (cfont.x_size)), y);
        else
            rotateChar(*st++, x, y, i, deg);
}

void print(char st[], int x, int y, int deg) {
    int mes;
    mes = strlen(st) + 1;
    char buf[mes];
    int i_edv;
    for (i_edv = 0; i_edv < mes; i_edv++)
        buf[i_edv] = st[i_edv];
    buf[mes] = NULL;
    // st.assign(buf, st.length()+1);    // It didn't work!! 
    // st.ToCharArray(buf, st.length()+1);  // Check above with 3line code and OK! WORKS
    print_1(buf, x, y, deg);
}

void printNumI(long num, int x, int y, int length, char filler) {
    char buf[25];
    char st[27];
    bool neg = false;
    int c = 0, f = 0, i;

    if (num == 0) {
        if (length != 0) {
            for (c = 0; c < (length - 1); c++)
                st[c] = filler;
            st[c] = 48;
            st[c + 1] = 0;
        } else {
            st[0] = 48;
            st[1] = 0;
        }
    } else {
        if (num < 0) {
            neg = true;
            num = -num;
        }

        while (num > 0) {
            buf[c] = 48 + (num % 10);
            c++;
            num = (num - (num % 10)) / 10;
        }
        buf[c] = 0;

        if (neg) {
            st[0] = 45;
        }

        if (length > (c + neg)) {
            for (i = 0; i < (length - c - neg); i++) {
                st[i + neg] = filler;
                f++;
            }
        }

        for (i = 0; i < c; i++) {
            st[i + neg + f] = buf[c - i - 1];
        }
        st[c + neg + f] = 0;

    }

    print(st, x, y, 0);
}

void printNumF(double num, byte dec, int x, int y, char divider, int length, char filler) {
    char st[27];
    bool neg = false;
    int i;

    if (dec < 1)
        dec = 1;
    else if (dec > 5)
        dec = 5;

    if (num < 0)
        neg = true;

    //  _convert_float(st, num, length, dec); //removed WATCH OUT THE FUNCTION DOES NOT WORK!!!

    if (divider != '.') {
        for (i = 0; i<sizeof (st); i++)
            if (st[i] == '.')
                st[i] = divider;
    }

    if (filler != ' ') {
        if (neg) {
            st[0] = '-';
            for (i = 1; i<sizeof (st); i++)
                if ((st[i] == ' ') || (st[i] == '-'))
                    st[i] = filler;
        } else {
            for (i = 0; i<sizeof (st); i++)
                if (st[i] == ' ')
                    st[i] = filler;
        }
    }

    print(st, x, y, 0);
}

void setFont(uint8_t* font) {
    cfont.font = font;
    cfont.x_size = fontbyte(0);
    cfont.y_size = fontbyte(1);
    cfont.offset = fontbyte(2);
    cfont.numchars = fontbyte(3);
}

uint8_t* getFont() {
    return cfont.font;
}

uint8_t getFontXsize() {
    return cfont.x_size;
}

uint8_t getFontYsize() {
    return cfont.y_size;
}

void drawBitmap_1(int x, int y, int sx, int sy, unsigned short* data, int scale) {
    unsigned int col;
    int tx, ty, tc, tsx, tsy;

    if (scale == 1) {
        if (orient == PORTRAIT) {
            LATGbits.LATG13 = 0; // CS 
            setXY(x, y, x + sx - 1, y + sy - 1);
            for (tc = 0; tc < (sx * sy); tc++) {
                col = pgm_read_word(&data[tc]);
                LCD_Write_DATA_1(col >> 8, col & 0xff);
            }
            LATGbits.LATG13 = 1; // CS 
        } else {
            LATGbits.LATG13 = 0; //  CS 
            for (ty = 0; ty < sy; ty++) {
                setXY(x, y + ty, x + sx - 1, y + ty);
                for (tx = sx - 1; tx >= 0; tx--) {
                    col = pgm_read_word(&data[(ty * sx) + tx]);
                    LCD_Write_DATA_1(col >> 8, col & 0xff);
                }
            }
            LATGbits.LATG13 = 1; // CS 
        }
    } else {
        if (orient == PORTRAIT) {
            LATGbits.LATG13 = 0; // CS 
            for (ty = 0; ty < sy; ty++) {
                setXY(x, y + (ty * scale), x + ((sx * scale) - 1), y + (ty * scale) + scale);
                for (tsy = 0; tsy < scale; tsy++)
                    for (tx = 0; tx < sx; tx++) {
                        col = pgm_read_word(&data[(ty * sx) + tx]);
                        for (tsx = 0; tsx < scale; tsx++)
                            LCD_Write_DATA_1(col >> 8, col & 0xff);
                    }
            }
            LATGbits.LATG13 = 1; // CS 
        } else {
            LATGbits.LATG13 = 0; // CS 
            for (ty = 0; ty < sy; ty++) {
                for (tsy = 0; tsy < scale; tsy++) {
                    setXY(x, y + (ty * scale) + tsy, x + ((sx * scale) - 1), y + (ty * scale) + tsy);
                    for (tx = sx - 1; tx >= 0; tx--) {
                        col = pgm_read_word(&data[(ty * sx) + tx]);
                        for (tsx = 0; tsx < scale; tsx++)
                            LCD_Write_DATA_1(col >> 8, col & 0xff);
                    }
                }
            }
            LATGbits.LATG13 = 1; // CS 
        }
    }
    clrXY();
}

void drawBitmap(int x, int y, int sx, int sy, unsigned short* data, int deg, int rox, int roy) {
    unsigned int col;
    int tx, ty, newx, newy;
    double radian;
    radian = deg * 0.0175;

    if (deg == 0)
        drawBitmap_1(x, y, sx, sy, data, 1);
    else {
        LATGbits.LATG13 = 0; // CS 
        for (ty = 0; ty < sy; ty++)
            for (tx = 0; tx < sx; tx++) {
                col = pgm_read_word(&data[(ty * sx) + tx]);

                newx = x + rox + (((tx - rox) * cos(radian))-((ty - roy) * sin(radian)));
                newy = y + roy + (((ty - roy) * cos(radian))+((tx - rox) * sin(radian)));

                setXY(newx, newy, newx, newy);
                LCD_Write_DATA_1(col >> 8, col & 0xff);
            }
        LATGbits.LATG13 = 1; // CS ;
    }
    clrXY();
}

/*void UTFT::setContrast(char c)
{
  LATGbits.LATG13 = 0; //cbi(P_CS, B_CS);
  switch (display_model)
  {
  case PCF8833:
    if (c>64) c=64;
    LCD_Write_COM(0x25);
    LCD_Write_DATA(c);
    break;
  }
  LATGbits.LATG13 = 1; //sbi(P_CS, B_CS);
}*/

int getDisplayXSize() {
    if (orient == PORTRAIT)
        return disp_x_size + 1;
    else
        return disp_y_size + 1;
}

int getDisplayYSize() {
    if (orient == PORTRAIT)
        return disp_y_size + 1;
    else
        return disp_x_size + 1;
}

void setBrightness(byte br) {
    LATGbits.LATG13 = 0; // CS 
    if (br > 16) br = 16;
    LCD_Write_COM_DATA(0x01, br);
    LCD_Write_COM(0x0F);
    LATGbits.LATG13 = 1; // CS 
}

void setDisplayPage(byte page) {
    LATGbits.LATG13 = 0; // CS 
    if (page > 7) page = 7;
    LCD_Write_COM_DATA(0x04, page);
    LCD_Write_COM(0x0F);
    LATGbits.LATG13 = 1; // CS 
}

void setWritePage(byte page) {
    LATGbits.LATG13 = 0; // CS 
    if (page > 7) page = 7;
    LCD_Write_COM_DATA(0x05, page);
    LCD_Write_COM(0x0F);
    LATGbits.LATG13 = 1; // CS 
}

void BackLight_On() {
    LATGbits.LATG13 = 0; //CS
    LCD_Write_COM(0x0053);
    LCD_Write_DATA_1(0x00, 0x24);
    LCD_Write_COM(0x0F);
    LATGbits.LATG13 = 1; //CS
}

void BackLight_OFF() {
    LATGbits.LATG13 = 0; //CS
    LCD_Write_COM(0x0053);
    LCD_Write_DATA_1(0x00, 0x00);
    LCD_Write_COM(0x0F);
    LATGbits.LATG13 = 1; //CS
}

// *****************************************************************************
// *****************************************************************************
// Section: Main Entry Point
// *****************************************************************************
// *****************************************************************************

void delay_ms(int count) {
    T1CON = 0x8030;
    while (count--) {
        TMR1 = 0;
        while (TMR1 < 0x4e);
    }
    T1CONbits.ON = 0;
}

int main(void) {
    /* Initialise all MPLAB Harmony modules, including application(s). */
    SYS_Initialize(NULL);
    DRV_SPI0_Initialize();              // SPI initialise 
    DRV_SPI_Open(SPI_ID_4,DRV_IO_INTENT_EXCLUSIVE ); 
    SYS_Tasks();       
    DRV_ADC_Initialize();               // Initialise ADC 
    
    Run_Stop_Marker=0;  
    Flag_SPI_Bat=false;
    Flag_SPI_USB=false; 
    for (i_SON = 1; i_SON < 7; i_SON++)
        {
        ONOFF_Chan[i_SON]=1;            // Start with ALL Channels ON
        Trans_ONOFF_Chan[i_SON]=0;      // Start with ALL Channels NOT Transmitting
        }
    All_OFF=0;                          // ALL ports are ON
//=========== Disable ALL Slaves SPI  ==  
    LATEbits.LATE9=1;                   // Slave EEPROM Select OFF
    LATFbits.LATF0=1;                   // Slave RTCC Select OFF    
    LATFbits.LATF3=1;                   // Slave 67K40 Select OFF     
    LATFbits.LATF12=1;                  // Slave 25Q10 Select OFF
//======================================   
    TFTU();                             // Initialise TFT
    setup();                            // Setup the LCD
    BackLight_On();                     // It doesn't seem to work XX
    fillScr_1(255, 255, 255);           // Fill screen with White
    show_scrn=0;
//<============= EEPROM First Load
    My_SPI_EEPROM_Read(0x00,0x1B,What_getEEPROMdata,1);    
    if (What_getEEPROMdata[0]==0xFF) 
        {                                           // initialise 1st Project if 00 1B is Blank
        //<============================= EEPROM ====================================
        W_Data[0]=0x31;         // Beep ON  
        W_Data[1]=0x36;         // Number of Channels 
        W_Data[2]=0x30;         // SN: # Device == 00102
        W_Data[3]=0x30;         //     # Device (in 4 digits)
        W_Data[4]=0x31;         //  
        W_Data[5]=0x30;         //  
        W_Data[6]=0x32;         //   
        W_Data[7]=0x31;         // Day 2 digits  
        W_Data[8]=0x34;         //  
        W_Data[9]=0x31;         //  Month 2 digits
        W_Data[10]=0x32;         //  
        W_Data[11]=0x31;         // Year 2 digits          
        W_Data[12]=0x39;         //  
        W_Data[13]=0x32;         // Firmware Version  2 digits
        W_Data[14]=0x31;         // 
        delay_ms(5);
        My_SPI_EEPROM_Write(0x00,0x00, W_Data, 15);        // Just Once save 0xFF
        delay_ms(5);
//            My_SPI_EEPROM_Read(0x00,0x00,What_getEEPROMdata,10);
//<=============================================================================   
        W_Data[0]=0x01;         // Project Number  
        W_Data[1]=0x40;         // Freq #1 -A 8000
        W_Data[2]=0x1F;         // Freq #1 -B  
        W_Data[3]=0x00;         // dBm #1
        W_Data[4]=0x40;         // Freq #2 -A
        W_Data[5]=0x1F;         // Freq #2 -B
        W_Data[6]=0x00;        // dBm #2
        W_Data[7]=0x40;         // Freq #3 -A
        W_Data[8]=0x1F;         // Freq #3 -B
        W_Data[9]=0x00;         // dBm #3  
        W_Data[10]=0x40;        // Freq #4 -A 8000
        W_Data[11]=0x1F;        // Freq #4 -B  
        W_Data[12]=0x00;        // dBm #4
        W_Data[13]=0x40;        // Freq #5 -A
        W_Data[14]=0x1F;        // Freq #5 -B
        W_Data[15]=0x00;       // dBm #5
        W_Data[16]=0x40;        // Freq #6 -A
        W_Data[17]=0x1F;        // Freq #6 -B
        W_Data[18]=0x00;        // dBm #6  
        W_Data[19]=0b00111111;  // Channels ON 
        delay_ms(5);
        My_SPI_EEPROM_Write(0x00,0x1E, W_Data, 20);         // 0x1E (30dec)
        delay_ms(5);
        W_Data[0]=0x01;         
        My_SPI_EEPROM_Write(0x00,0x1B, W_Data, 1);        // Project #1 in 00 1B 
        delay_ms(5);
        } 
//<======== Load EEPROM Stored Values  
 //   Debug_index=next_page_index();
    My_SPI_EEPROM_Read(0x00,0x1B, What_getEEPROMdata,1);    // Last entered Project Number in EEPROM 00 1B 
    projectNum=What_getEEPROMdata[0];                       // Find the last entered ProjectNum    
    Lat_ProjNum=projectNum;
    Curr_ProjNum =projectNum; 
    True_ProjNum=Get_True(projectNum);
    addr_Num=True_ProjNum * 10 + (True_ProjNum+1)*10;           // Calculate the Project's address 
    addr_Num +=1;                                           // The first Address is the Number of Project
    for (i_test_flash = 1; i_test_flash <= 6; i_test_flash++)               // Print last entered values 
        {
        Adr_Arr[1]=(addr_Num&0xFF);                                         //extract first byte
        Adr_Arr[0]=((addr_Num>>8)&0xFF);                                    //extract second byte
        My_SPI_EEPROM_Read(Adr_Arr[0],Adr_Arr[1], What_getEEPROMdata,2);        
        Freq_IN[i_test_flash]=(What_getEEPROMdata[1]<<8)+What_getEEPROMdata[0];  // Load stored Values
        addr_Num+=2;
        Adr_Arr[1]=(addr_Num&0xFF);                                             //extract first byte
        Adr_Arr[0]=((addr_Num>>8)&0xFF);                                        //extract second byte
        My_SPI_EEPROM_Read(Adr_Arr[0],Adr_Arr[1], What_getEEPROMdata,1);        
        dBmPower[i_test_flash]=What_getEEPROMdata[0];                 
        addr_Num+=1;
        } 
//<======== Load  EEPROM Stored Values  END         
    for (i_for=1; i_for <=6; i_for++)               // DE_Activate channels (ALL 1-6)
        {
//        PDN_Ampl_DE_Activate(i_for);
        PDRF_PLL_DE_Activate(i_for);    
        }   
    
//+++++++++============================ HOME Screen Start
    while(true) 
    {     
        if (show_scrn==0)
        {
            drawBitmap_1 (0, 0, 480, 320, Main_Screen_6, 1);        // Show Main Screen 5(PCTEL) 6(ATEC)
            //<=
            setColor(VGA_RED);             // Set color to all Draw, Fill and Print(letters)
            fillRect(0,296,480,319);
            setColor(VGA_WHITE);            // Set color to all Draw, Fill and Print(letters)
            setBackColor(VGA_RED);  
            setFont(arial_8x16); //Arial_round_16x24);         // Back to Arial 16X24 // <------     
            print(" CHANNELS (F1)   PROJECTS (F2)   SETTINGS (F3)   HELP (F4)", 2, 302, 0); // Hor,Vert,Rotate
            //<=
            setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters) 
            draw_battery();
            delay_ms(5);                     // Delay 5 seconds  
            show_scrn=1;
        }
        draw_battery();  
        LATFbits.LATF0=1;                                                           // Slave RTCC Select OFF                
        APP_SPI_CS_DESELECT();                                                      // EEPROM Select OFF
        LATFbits.LATF3=1;                                                           // Slave 67K40 Select OFF 
        LATFbits.LATF12=1;                                                         // Slave 25Q10 Select OFF 
        delay_ms(100);          
        if (key_int == 59)            // 59 F1  CHANNELS
            {
            Channels_In();
            }
        if (key_int == 60)            //  60 F2 PROJECTS
            {
            Project_In();
            }
        if (key_int == 61)            //  61 F3 SETTINGS
            {
            Settings_In();
            }
        if (key_int == 62)            //  62 F4 HELP
            {
            Help_In();
            }  
        if (key_int == 117)            // 117 UP_arrow Lamda Settings
            {
            Lamda_Set();
            }        
        if (key_int == 100)          //  100 Down Arrow 
            {
            dBmBool=false;           // Attenuation Values are getting in 
            Calib();
            } 
       if (key_int == 15)          //  15 Shift 
            {
            dBmBool=true;           // dBm Values are getting in 
            Calib();
            }         
        if (key_int == 51)          //  51 number "3" 
            {
            Turn_OFF();
            }         
//+++++++++============================ HOME Screen End        
    }

    

    /* Execution should not come here during normal operation */

    return ( EXIT_FAILURE);
}


//void PDN_Ampl_Activate(uint8_t channel)
//{
//  switch (channel) 
//    {
//        case 1:
//            LATCbits.LATC2=0;       //PDN_AMPL_1Off();
//            break;
//        case 2:
//            LATEbits.LATE8=0 ;       //PDN_AMPL_2Off();
//            break;
//        case 3:
//            LATBbits.LATB4=0;         //PDN_AMPL_3Off();
//            break;
//        case 4:
//            LATBbits.LATB2=0;           //PDN_AMPL_4Off();
//            break;
//        case 5:
//            LATBbits.LATB0=0;       //PDN_AMPL_5Off();
//            break;
//        case 6:
//            LATBbits.LATB8=0;       //PDN_AMPL_6Off();
//            break;
//        default:
//            break;
//    } 
//    return;  
//}

//void PDRF_PLL_Activate(uint8_t channel)
//{
// switch (channel) 
//    {
//        case 1:
//            PDRF_PLL_1On();
//            break;
//        case 2:
//            PDRF_PLL_2On();
//            break;
//        case 3:
//            PDRF_PLL_3On();
//            break;
//        case 4:
//            PDRF_PLL_4On();
//            break;
//        case 5:
//            PDRF_PLL_5On();
//            break;
//        case 6:
//            PDRF_PLL_6On();
//            break;
//        default:
//            break;
//    }
//    return;  
//}

void PDRF_PLL_DE_Activate(uint8_t channel)
{
    send_SPI_settings(channel, 0, 0);   // Send 0 Frequency and 0 Power --6GHz--
    return;  
}

//void PDN_Ampl_DE_Activate(uint8_t channel)
//{
// switch (channel) 
//    {
//        case 1:
//            PDN_AMPL_1On(); 
//            break;
//        case 2:
//           PDN_AMPL_2On() ;
//            break;
//        case 3:
//            PDN_AMPL_3On() ;
//            break;
//        case 4:
//            PDN_AMPL_4On() ;
//            break;
//        case 5:
//            PDN_AMPL_5On() ;
//            break;
//        case 6:
//            PDN_AMPL_6On() ;
//            break;
//        default:
//            break;
//    }
//    return;  
//}

void send_SPI_settings(uint8_t channel_s, uint16_t Freq_IN_s, int8_t Power_s )
{
 //<--------------------------------- 
    //channel = 4;
//    PDN_Ampl_DE_Activate(channel_s);
//    PDRF_PLL_DE_Activate(channel_s);     
    
    delay_ms(200); 

    dataOut[0] = 0xFF;          // Dummy Byte
    if (dBmBool)
        dataOut[1] = 0xCD;      // dBm Inputs
    else
        dataOut[1] = 0xAA;      // Attenuation Inputs     
    dataOut[2]= (Freq_IN_s & 0xff00)>>8;
    dataOut[3]= Freq_IN_s & 0x00ff;
    Power_s+=20;                    // offset +20 to set the range 0~40 <for Attenuation there is no need +20 we do not have negative numbers!
    dataOut[4] = Power_s; // <==Attenuation>  //<Power_s& 0x00ff;>== dBm     // Take only the LSByte number 0~40    // POWER  
    dataOut[5] = channel_s | 0b10000000;                                        // 
    
    LATEbits.LATE9=1;                   // Slave EEPROM Select OFF
    LATFbits.LATF0=1;                   // Slave RTCC Select OFF      
    LATFbits.LATF12=1;                  // Slave 25Q10 Select OFF
    LATFbits.LATF3=0;                   // Slave 67K40 Select ON    
    delay_ms(1);      
    PLIB_SPI_BufferWrite (SPI_ID_4,dataOut[0]);
    delay_ms(1); 
    PLIB_SPI_BufferWrite (SPI_ID_4,dataOut[1]);
    delay_ms(1); 
    PLIB_SPI_BufferWrite (SPI_ID_4,dataOut[2]);
    delay_ms(1); 
    PLIB_SPI_BufferWrite (SPI_ID_4,dataOut[3]);
    delay_ms(1); 
    PLIB_SPI_BufferWrite (SPI_ID_4,dataOut[4]);
    delay_ms(1); 
    PLIB_SPI_BufferWrite (SPI_ID_4,dataOut[5]);
    //DRV_SPI0_BufferAddWriteRead(*Data_Out, *Data_In, 4);
    delay_ms(1);
    //  test_IN=PLIB_SPI_BufferRead(1);
    //SS_67K40On();
    LATEbits.LATE9=1;                   // Slave EEPROM Select OFF
    LATFbits.LATF0=1;                   // Slave RTCC Select OFF    
    LATFbits.LATF3=1;                   // Slave 67K40 Select OFF     
    LATFbits.LATF12=1;                  // Slave 25Q10 Select OFF
    delay_ms(30);                                                               // Wait before Activating PLL + Amplifier
  
//    if (Freq_IN_s != 0)           // NOT Used for 6GHz           // If Frequency EQUAL 0 do not Activate
//    {
//        PDN_Ampl_Activate(channel_s);
//        PDRF_PLL_Activate(channel_s);
//        delay_ms(5);        
//    }
  
    //<---------------------
    return;     
}

uint8_t get_channel(void)
{
uint8_t num_chan, h_check_flag;
char back_ch;
h_check_flag=0;
while(true)                         // Wait for ANY key
    {
    delay_ms(100);  
    if ((key_int >= 0x31)&& (key_int <= 0x36)&& (h_check_flag==0))          // Ensure that only 1 character is entered 
        {
        printChar(key_int, x_pos,y_pos);
        x_pos +=16; 
        back_ch=key_int;
        h_check_flag=1;
        // break;  
        }
    if ((key_int == 108) && (h_check_flag==1))                                  // BackSpace 
        {
        x_pos -=16; 
        printChar(0x20, x_pos,y_pos);
        h_check_flag=0;
        }
    if ((key_int == 0x0A)&& (h_check_flag==1))
        {      
        break;  
        }   
    }
num_chan= back_ch & 0x0F;
delay_ms(200); 
return(num_chan);
}

int get_dBmP(void)
{
char back_ch;    
uint8_t h_check_flag, error_flag, i_count;
char dBm_chars[3];
int num_dBm, sign_dBm, x_pos_dB, y_pos_dB;
h_check_flag=0;
i_count=0;
num_dBm=0;
sign_dBm=1;
error_flag=0;
x_pos_dB=x_pos;
y_pos_dB= y_pos;
if (ONOFF_Chan[YB_posY]== 1)
    {
    setColor(VGA_BLACK);
    setFont(Arial_round_16x24);
    setBackColor_1(217,217,217);      
    print("Transmission STOPED for ch.", 10, 260, 0);                  // Message 
    printNumI(YB_posY, 440, 260, 1, ' '); 
    setColor(VGA_YELLOW);     
    if (YB_posY==1)
        fillCircle( 430,106,8);  	// Ch. 1
    if (YB_posY==2)
        fillCircle( 430,133,8);  	// Ch. 2
    if (YB_posY==3)                    
       fillCircle( 430,160,8);  	// Ch. 3
    if (YB_posY==4)                     
        fillCircle( 430,187,8);  	// Ch. 4  
   // if (YB_posY==5)  
     //   fillCircle( 430,214,8);  	// Ch. 5
    //if (YB_posY==6)
      //  fillCircle( 430,241,8);  	// Ch. 6
    Trans_ONOFF_Chan[YB_posY]=0;                                // Transmit OFF
    LED_CHAN_DE_Activate(YB_posY);                              // Turn LED OFF
//    PDN_Ampl_DE_Activate(YB_posY);                              // PDN OFF
    PDRF_PLL_DE_Activate(YB_posY);                              // PDRF OFF
    }
setColor(VGA_BLACK);
if ((YB_posY==1)||(YB_posY==3)||(YB_posY==5))
    setBackColor_1(174,174,174);        // Dark Grey 
else
    setBackColor_1(217,217,217);        // Light Grey 
delay_ms(300);
if (key_int== 0x0A)                  // <====== I've entered this to prevent getting ENTER double-Pressed 
    {
    delay_ms(500); 
    }
key_int=0;
while(true)                                                                     // Wait for ANY key
    {
    delay_ms(keyb_sens);  // Old delay_ms(200)  // Keyboard Sensitivity 
    if (i_count >= 3)
        {
        h_check_flag=1;
        }
    else
        {
        h_check_flag=0;  
        }
    if ((key_int >= 0x30)&& (key_int <= 0x39)&& (h_check_flag==0)|| (key_int==45)|| (key_int==27))              //  
        {
        if (key_int == 27)                              // ESC enter 0 and break
            {
            dBm_chars[0] =0;
            dBm_chars[1] =0;
            x_pos=YB_X1 +32;
            y_pos=YB_Y1 +3;
            print("00  ", x_pos, y_pos, 0);   
            i_count=2;
            break;
            }
        printChar(key_int, x_pos-2,y_pos);
        x_pos +=16; 
        dBm_chars[i_count]=key_int;
        i_count++; 
        if (i_count >= 3)                               // If more than 3 characters entered
            {
            h_check_flag=1;
            error_flag=1;
            break;
            }
        delay_ms(keyb_sens);    //delay_ms(100)     // Keyboard Sensitivity  
        }
    if ((key_int == 108))                                                       // BackSpace 
        {
        if (i_count >0)
            {
            x_pos -=16; 
            printChar(0x20, x_pos,y_pos);
            i_count--;
            }  
        }
    if ((key_int == 0x0A))
        {      
        break;  
        }   
    }
if (dBm_chars[0] == 45)                                                         // 45 (-)
    {
    if (i_count==3)
        {
        num_dBm= 10*(dBm_chars[1] & 0x0F);
        num_dBm += (dBm_chars[2] & 0x0F);
        num_dBm *= -1;   
        error_flag=0;
        }
    if (i_count==2)
       {
        num_dBm = (dBm_chars[1] & 0x0F);
        num_dBm *= -1;  
        error_flag=0;
       }                                                        // Negative number
    if ((i_count==0)||(i_count==1))
        {
        error_flag=1;
        num_dBm=-50;     
        }            
    }
else
    {
    if (i_count==3)
        {
        error_flag=1;
//        print("---   ", x_pos, y_pos, 0);
//        setBackColor_1(217,217,217);          
//        print("Error Try Again                 ", 10, 260, 0);              // Message Error   
        num_dBm=0;      ///-1000;                                                      // Notify the ERROR
        }
    else 
        {
        if (i_count==2)
            {
            num_dBm= 10*(dBm_chars[0] & 0x0F);
            num_dBm += (dBm_chars[1] & 0x0F);
            }
        if (i_count==1)
            {            
            num_dBm = (dBm_chars[0] & 0x0F);
            }
        if (i_count==0)
            {
            error_flag=1;
//            print("---   ", x_pos, y_pos, 0);            
//            setBackColor_1(217,217,217);          
//            print("Error Try Again                 ", 10, 260, 0);              // Message Error   
            num_dBm=0;              //-50;     
            }        
        }
    }
//<=============== Start Max Min  
   if ((Freq_IN[YB_posY] >= 1375)&& (Freq_IN[YB_posY] < 1440))       //1375	1440  138
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_138, Max_138);     
        }
    if ((Freq_IN[YB_posY] >= 1440)&& (Freq_IN[YB_posY] <1750 ))       //1440	1750	150
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_150, Max_150);      
        }
    if ((Freq_IN[YB_posY] >= 1750)&& (Freq_IN[YB_posY] < 3000))       //1750	3000   200
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_200, Max_200);        
        }
    if ((Freq_IN[YB_posY] >= 3000)&& (Freq_IN[YB_posY] < 5000))       //3000	5000	400
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_400, Max_400);         
        }
    if ((Freq_IN[YB_posY] >= 5000)&& (Freq_IN[YB_posY] < 6500))       //5000	6500	600
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_600, Max_600);     
        }
    if ((Freq_IN[YB_posY] >= 6500)&& (Freq_IN[YB_posY] < 7500))       //6500	7500	700
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_700, Max_700);     
        }
    if ((Freq_IN[YB_posY] >= 7500)&& (Freq_IN[YB_posY] < 8500))       //7500	8500	800
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_800, Max_800);      
        }
    if ((Freq_IN[YB_posY] >= 8500)&& (Freq_IN[YB_posY] < 10000))       //8500	10000	900
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_900, Max_900);       
        }
    if ((Freq_IN[YB_posY] >= 10000)&& (Freq_IN[YB_posY] < 12500))       //10000	12500	1100
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_1100, Max_1100);              
        }
    if ((Freq_IN[YB_posY] >= 12500)&& (Freq_IN[YB_posY] < 14500))       //12500	14500	1400
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_1400, Max_1400);          
        }
    if ((Freq_IN[YB_posY] >= 14500)&& (Freq_IN[YB_posY] < 15500))       //14500	15500	1500
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_1500, Max_1500);              
        }
    if ((Freq_IN[YB_posY] >= 15500)&& (Freq_IN[YB_posY] < 16500))       //15500	16500	1600
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_1600, Max_1600);                 
        }
    if ((Freq_IN[YB_posY] >= 16500)&& (Freq_IN[YB_posY] < 17500))       //16500	17500	1700
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_1700, Max_1700);                 
        }
    if ((Freq_IN[YB_posY] >= 17500)&& (Freq_IN[YB_posY] < 18500))       //17500	18500	1800
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_1800, Max_1800);                
        }
    if ((Freq_IN[YB_posY] >= 18500)&& (Freq_IN[YB_posY] < 19500))       //18500	19500	1900
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_1900, Max_1900);                
        }
    if ((Freq_IN[YB_posY] >= 19500)&& (Freq_IN[YB_posY] < 20500))       //19500	20500	2000
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_2000, Max_2000);                
        }
    if ((Freq_IN[YB_posY] >= 20500)&& (Freq_IN[YB_posY] < 22000))       //20500	22000	2100
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_2100, Max_2100);      
        }
    if ((Freq_IN[YB_posY] >= 22000)&& (Freq_IN[YB_posY] < 24500))       //22000	24500	2300
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_2300, Max_2300);                  
        }
    if ((Freq_IN[YB_posY] >= 24500)&& (Freq_IN[YB_posY] < 26500))       //24500	26500	2600
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_2600, Max_2600);         
        }
    if ((Freq_IN[YB_posY] >= 26500)&& (Freq_IN[YB_posY] < 27500))       //26500	27500	2700
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_2700, Max_2700);             
        }
    if ((Freq_IN[YB_posY] >= 27500)&& (Freq_IN[YB_posY] < 29000))       //27500	29000	2800
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_2800, Max_2800);      
        }
    if ((Freq_IN[YB_posY] >= 29000)&& (Freq_IN[YB_posY] < 31500))       //29000	31500	3000
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_3000, Max_3000);      
        }
    if ((Freq_IN[YB_posY] >= 31500)&& (Freq_IN[YB_posY] < 34000))       //31500	34000	3300
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_3300, Max_3300);      
        }
    if ((Freq_IN[YB_posY] >= 34000)&& (Freq_IN[YB_posY] < 36000))       //34000	36000	3500
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_3500, Max_3500);                   
        }
    if ((Freq_IN[YB_posY] >= 36000)&& (Freq_IN[YB_posY] < 38500))       //36000	38500	3700
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_3700, Max_3700);                   
        }
    if ((Freq_IN[YB_posY] >= 38500)&& (Freq_IN[YB_posY] < 40500))       //38500	40500	4000
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_4000, Max_4000);      
        }
    if ((Freq_IN[YB_posY] >= 40500)&& (Freq_IN[YB_posY] < 42000))       //40500	42000	4100
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_4100, Max_4100);               
        }
    if ((Freq_IN[YB_posY] >= 42000)&& (Freq_IN[YB_posY] < 44000))       //42000	44000	4300
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_4300, Max_4300);             
        }
    if ((Freq_IN[YB_posY] >= 44000)&& (Freq_IN[YB_posY] < 46000))       //44000	46000	4500
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_4500, Max_4500);                  
        }
    if ((Freq_IN[YB_posY] >= 46000)&& (Freq_IN[YB_posY] < 48500))       //46000	48500	4700
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_4700, Max_4700);                 
        }
    if ((Freq_IN[YB_posY] >= 48500)&& (Freq_IN[YB_posY] < 50500))       //48500	50500	5000
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_5000, Max_5000);                
        }
    if ((Freq_IN[YB_posY] >= 50500)&& (Freq_IN[YB_posY] < 52000))       //50500	52000	5100
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_5100, Max_5100);                
        }
    if ((Freq_IN[YB_posY] >= 52000)&& (Freq_IN[YB_posY] < 54000))       //52000	54000	5300
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_5300, Max_5300);           
        }
    if ((Freq_IN[YB_posY] >= 54000)&& (Freq_IN[YB_posY] < 56000))       //54000	56000	5500
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_5500, Max_5500);                  
        }
    if ((Freq_IN[YB_posY] >= 56000)&& (Freq_IN[YB_posY] < 58500))        //56000	58500	5700
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_5700, Max_5700);               
        }
    if ((Freq_IN[YB_posY] >= 58500)&& (Freq_IN[YB_posY] <= 60000))       //58500	6000	6000
        {
        num_dBm=Min_Max_Power(num_dBm,x_pos_dB,y_pos_dB,Min_6000, Max_6000);               
        }     
   
//<=============== Enter 
if (error_flag==1)                    // old //((num_dBm<-20) || (num_dBm>20)|| 
    {
    x_pos=YB_X1 +32;
    y_pos=YB_Y1 +3;
    print("~  ", x_pos, y_pos, 0);        
    setBackColor_1(217,217,217);          
    print("Error Try Again                 ", 10, 260, 0);                      // Message Error 
    delay_ms(1000); 
    num_dBm=-1000;
    }
else
    {
    setColor(VGA_GREEN);                                                        // Draw new YB
    drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2); 
    }

setColor(VGA_BLACK);
setFont(Arial_round_16x24);
setBackColor_1(217,217,217);          
print("                                    ", 10, 260, 0);      
delay_ms(keyb_sens);      // old delay_ms(200);  // Keyboard Sensitivity
return(num_dBm);
}


int get_Freq(void)
{
    char error_flag_f,dp_pos;
    int x_pos_GF, y_pos_GF,x_pos_dB, y_pos_dB;
    
    x_pos_dB=x_pos+135;
    y_pos_dB=y_pos;
    
    Stack[0]=0;             // Stack Global Problem with Optimiser
    Stack[1]=0;
    Stack[2]=0;
    Stack[3]=0;
    Stack[4]=0;
    Stack[5]=0;
    error_flag_f=0;
    dp_pos=0;
    i=0;
    char_count=0;
    x_pos_GF=x_pos;
    y_pos_GF=y_pos;
    if (ONOFF_Chan[YB_posY]== 1)
        {
        setColor(VGA_BLACK);
        setFont(Arial_round_16x24);
        setBackColor_1(217,217,217);      
        print("Transmission STOPED for ch.", 10, 260, 0);                  // Message Error
        printNumI(YB_posY, 440, 260, 1, ' '); 
        setColor(VGA_YELLOW);     
        if (YB_posY==1)
            fillCircle( 430,106,8);  	// Ch. 1
        if (YB_posY==2)
            fillCircle( 430,133,8);  	// Ch. 2
        if (YB_posY==3)                    
           fillCircle( 430,160,8);  	// Ch. 3
        if (YB_posY==4)                     
            fillCircle( 430,187,8);  	// Ch. 4  
       // if (YB_posY==5)  
         //   fillCircle( 430,214,8);  	// Ch. 5
        //if (YB_posY==6)
          //  fillCircle( 430,241,8);  	// Ch. 6
        Trans_ONOFF_Chan[YB_posY]=0;                                // Transmit OFF
        LED_CHAN_DE_Activate(YB_posY);                              // Turn LED OFF
//        PDN_Ampl_DE_Activate(YB_posY);                              // PDN OFF
        PDRF_PLL_DE_Activate(YB_posY);                              // PDRF OFF
        }
    setColor(VGA_BLACK);
    if ((YB_posY==1)||(YB_posY==3)||(YB_posY==5))
        setBackColor_1(174,174,174);        // Dark Grey 
    else
        setBackColor_1(217,217,217);        // Light Grey 
    delay_ms(300);
    if (key_int== 0x0A)                  // <====== I've entered this to prevent getting ENTER double-Pressed 
        {
        delay_ms(500); 
        }
    //key_int=0;                        // Keep entered key
    while(true)                         // Wait for ANY key
        {
        delay_ms(keyb_sens);  // old delay_ms(100)   // Keyboard Sensitivity 
        if ((key_int >= 0x30)&& (key_int <= 0x39)|| (key_int==46)|| (key_int==27) )
            {
            if (key_int == 27)
                {
                Stack[0]=0;             // Stack Global Problem with Optimiser
                Stack[1]=0;
                Stack[2]=0;
                Stack[3]=0;
                Stack[4]=0;
                Stack[5]=0;
                x_pos=YB_X1 +10;
                y_pos=YB_Y1 +3;
                print("000   ", x_pos, y_pos, 0);
                i=3;                                                            // Needed for calculation
                char_count=4;
                break;
                }
            printChar(key_int, x_pos,y_pos);
            x_pos +=16;
            if ((key_int >= 0x30)&& (key_int <= 0x39))
               Stack[i]= key_int & 0x0F;
            char_count++;
            i++;
            if (key_int==46)                                                    // Locate where the dpoint 
            {
               dp_pos=i; 
            }
            if(i>=6)
                break;
            delay_ms(keyb_sens);  // old delay_ms(100)    // Keyboard Sensitivity 
            }
        if ((key_int == 108))                                  // BackSpace 
            {
            if (i >0)
                {
                x_pos -=16; 
                printChar(0x20, x_pos,y_pos);
                i--;
                char_count--;
                }  
            }
        if (key_int == 0x0A)                                                    // Enter Finished
            break;    
        }
    Num_ret=0;
    if ((char_count<3)|| (char_count>6))                                        // min=3 max=6
        error_flag_f=1;
       
    if (dp_pos==0)
    {
        if ((i>=5) || (i<3))
            error_flag_f=1;
        
        if (i==3)
        {
            Num_ret+=(Stack[0]& 0x0F)*1000;
            Num_ret+=(Stack[1]& 0x0F)*100;
            Num_ret+=(Stack[2]& 0x0F)*10;  
        }
        if (i==4)
        {
            Num_ret+=(Stack[0]& 0x0F)*10000;
            Num_ret+=(Stack[1]& 0x0F)*1000;
            Num_ret+=(Stack[2]& 0x0F)*100;
            Num_ret+=(Stack[3]& 0x0F)*10;       
        }
        
    }
    
    if (dp_pos==4)
    {
        Num_ret+=(Stack[0]& 0x0F)*1000;
        Num_ret+=(Stack[1]& 0x0F)*100;
        Num_ret+=(Stack[2]& 0x0F)*10;
        Num_ret+=(Stack[4]& 0x0F);    
    }
    
    if (dp_pos==5)
    {
        Num_ret+=(Stack[0]& 0x0F)*10000;
        Num_ret+=(Stack[1]& 0x0F)*1000;
        Num_ret+=(Stack[2]& 0x0F)*100;
        Num_ret+=(Stack[3]& 0x0F)*10;    
        Num_ret+=(Stack[5]& 0x0F);   
    }
 
    if ((dp_pos ==1)|| (dp_pos ==2)||(dp_pos ==3) ||(dp_pos ==6))
        error_flag_f=1; 
//<==============    
    if ((Num_ret<1375)&& (Num_ret>0))
        {
        Num_ret=1375;
        printNumI(Num_ret/10,x_pos_GF, y_pos_GF, 4, ' ');   // Print Frequency NO DOT POINT!!!
        print("Lowest applicable Frequency ", 7, 260, 0); 
        delay_ms(1000);          
        }
    if (Num_ret>Frq_limit)
        {
        Num_ret=Frq_limit;
        printNumI(Num_ret/10,x_pos_GF, y_pos_GF, 4, ' ');   // Print Frequency NO DOT POINT!!!
        print("Highest applicable Frequency ", 7, 260, 0); 
        delay_ms(1000);
        }
    if (error_flag_f==1)      //   if (((Num_ret<1375)&& (Num_ret>0))|| (Num_ret>44000) || (error_flag_f==1))
        {     
        x_pos=YB_X1 +1;
        y_pos=YB_Y1 +3;
        print(" ---   ", x_pos, y_pos, 0);
        setBackColor_1(217,217,217);          
        print("Error Try Again                 ", 10, 260, 0);                  // Message Error 
        delay_ms(1000);  
        Num_ret=0;
        }
    else
        {
        setColor(VGA_GREEN);                                           // Draw new YB
        drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2);        
        }
   
//<=============== Start Max Min  
    setColor(VGA_BLACK);    
   if ((Num_ret >= 1375)&& (Num_ret < 1440))       //1375	1440  138
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_138, Max_138);     
        }
    if ((Num_ret >= 1440)&& (Num_ret <1750 ))       //1440	1750	150
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_150, Max_150);    
        }
    if ((Num_ret >= 1750)&& (Num_ret < 3000))       //1750	3000   200
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_200, Max_200);    
        }
    if ((Num_ret >= 3000)&& (Num_ret < 5000))       //3000	5000	400
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_400, Max_400);     
        }
    if ((Num_ret >= 5000)&& (Num_ret < 6500))       //5000	6500	600
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_600, Max_600);     
        }
    if ((Num_ret >= 6500)&& (Num_ret < 7500))       //6500	7500	700
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_700, Max_700);     
        }
    if ((Num_ret >= 7500)&& (Num_ret < 8500))       //7500	8500	800
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_800, Max_800);     
        }
    if ((Num_ret >= 8500)&& (Num_ret < 10000))       //8500	10000	900
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_900, Max_900);      
        }
    if ((Num_ret >= 10000)&& (Num_ret < 12500))       //10000	12500	1100
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_1100, Max_1100);             
        }
    if ((Num_ret >= 12500)&& (Num_ret < 14500))       //12500	14500	1400
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_1400, Max_1400);         
        }
    if ((Num_ret >= 14500)&& (Num_ret < 15500))       //14500	15500	1500
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_1500, Max_1500);             
        }
    if ((Num_ret >= 15500)&& (Num_ret < 16500))       //15500	16500	1600
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_1600, Max_1600);                
        }
    if ((Num_ret >= 16500)&& (Num_ret < 17500))       //16500	17500	1700
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_1700, Max_1700);                
        }
    if ((Num_ret >= 17500)&& (Num_ret < 18500))       //17500	18500	1800
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_1800, Max_1800);               
        }
    if ((Num_ret >= 18500)&& (Num_ret < 19500))       //18500	19500	1900
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_1900, Max_1900);               
        }
    if ((Num_ret >= 19500)&& (Num_ret < 20500))       //19500	20500	2000
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_2000, Max_2000);               
        }
    if ((Num_ret >= 20500)&& (Num_ret < 22000))       //20500	22000	2100
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_2100, Max_2100);     
        }
    if ((Num_ret >= 22000)&& (Num_ret < 24500))       //22000	24500	2300
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_2300, Max_2300);                 
        }
    if ((Num_ret >= 24500)&& (Num_ret < 26500))       //24500	26500	2600
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_2600, Max_2600);        
        }
    if ((Num_ret >= 26500)&& (Num_ret < 27500))       //26500	27500	2700
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_2700, Max_2700);            
        }
    if ((Num_ret >= 27500)&& (Num_ret < 29000))       //27500	29000	2800
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_2800, Max_2800);     
        }
    if ((Num_ret >= 29000)&& (Num_ret < 31500))       //29000	31500	3000
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_3000, Max_3000);     
        }
    if ((Num_ret >= 31500)&& (Num_ret < 34000))       //31500	34000	3300
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_3300, Max_3300);    
        }
    if ((Num_ret >= 34000)&& (Num_ret < 36000))       //34000	36000	3500
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_3500, Max_3500);                  
        }
    if ((Num_ret >= 36000)&& (Num_ret < 38500))       //36000	38500	3700
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_3700, Max_3700);                  
        }
    if ((Num_ret >= 38500)&& (Num_ret < 40500))       //38500	40500	4000
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_4000, Max_4000);     
        }
    if ((Num_ret >= 40500)&& (Num_ret < 42000))       //40500	42000	4100
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_4100, Max_4100);              
        }
    if ((Num_ret >= 42000)&& (Num_ret < 44000))       //42000	44000	4300
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_4300, Max_4300);            
        }
    if ((Num_ret >= 44000)&& (Num_ret < 46000))       //44000	46000	4500
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_4500, Max_4500);                 
        }
    if ((Num_ret >= 46000)&& (Num_ret < 48500))       //46000	48500	4700
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_4700, Max_4700);                
        }
    if ((Num_ret >= 48500)&& (Num_ret < 50500))       //48500	50500	5000
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_5000, Max_5000);               
        }
    if ((Num_ret >= 50500)&& (Num_ret < 52000))       //50500	52000	5100
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_5100, Max_5100);               
        }
    if ((Num_ret >= 52000)&& (Num_ret < 54000))       //52000	54000	5300
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_5300, Max_5300);          
        }
    if ((Num_ret >= 54000)&& (Num_ret < 56000))       //54000	56000	5500
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_5500, Max_5500);                 
        }
    if ((Num_ret >= 56000)&& (Num_ret < 58500))        //56000	58500	5700
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_5700, Max_5700);              
        }
    if ((Num_ret >= 58500)&& (Num_ret <= 60000))       //58500	6000	6000
        {
        dBmPower[YB_posY]=Min_Max_Power(dBmPower[YB_posY],x_pos_dB,y_pos_dB,Min_6000, Max_6000);              
        }  
//<=============== Enter 
    setColor(VGA_BLACK);
    setFont(Arial_round_16x24);
    setBackColor_1(217,217,217);          
    print("                                 ", 10, 260, 0);                  // Message Error
    delay_ms(keyb_sens);  // old delay_ms(100); // Keyboard Sensitivity
    return(Num_ret);
}

void LED_CHAN_Activate(uint8_t channel)
{
 switch (channel) 
    {
        case 1:
            LED_2On(); 
            break;
        case 2:
           LED_4On();
            break;
        case 3:
            LED_6On() ;
            break;
        case 4:
            LED_8On() ;
            break;
        case 5:
            LED_10On() ;
            break;
        case 6:
            LED_12On();
            break;
        default:
            break;
    }
    return;  
}


void LED_CHAN_DE_Activate(uint8_t channel)
{
 switch (channel) 
    {
        case 1:
            LED_2Off(); 
            break;
        case 2:
           LED_4Off();
            break;
        case 3:
            LED_6Off();
            break;
        case 4:
            LED_8Off();
            break;
        case 5:
            LED_10Off();
            break;
        case 6:
            LED_12Off();
            break;
        default:
            break;
    }
    return;      
}

void draw_battery()
{
uint8_t index_SPI_read; 
// GLOBAL uint16_t Bat1_ADC, Bat2_ADC, USB_ADC;

if (Collect==1)         // Every second // OLD modulus 2
    {
        SPI_Voltages(2); 
        delay_ms(20); 
        SPI_Voltages(1);
//    index_SPI_read=5;
//    while ((!Flag_SPI_USB) && (index_SPI_read>0))
//        {
//        SPI_Voltages(2);   
//        index_SPI_read--;
//        }
//    index_SPI_read=5;
//    while ((!Flag_SPI_Bat) && (index_SPI_read>0))
//        {
//        SPI_Voltages(1);   
//        index_SPI_read--;
//        }
    if (USB_ADC<= 300)     //Flag_SPI_Bat)             // && Flag_SPI_USB)
        {
        // DELETE Capacity Bars!!!   
        setColor_1(217,217,217);            // Grey Set color to all Draw, Fill and Print(letters)
        fillRect(404,11,424,21);
        setColor(VGA_BLACK);                // Back to Black Set color to all Draw, Fill and Print(letters) 
        
        drawLine(404,21,420,21);            // Draw contour 
        drawLine(420,21,420,18);
        drawLine(420,18,424,18);
        drawLine(424,18,424,14);
        drawLine(424,14,420,14);
        drawLine(420,14,420,11);
        drawLine(420,11,404,11);
        drawLine(404,11,404,21);  
        
//        printNumI(Bat2_ADC, 440, 260, 1, ' ');     // DE-BUGGING 
// capacity bars        
        if (Bat1_ADC<Bat2_ADC)                   // Bat1 OFF Draw for BAT2 // <100
            {
            if (Bat2_ADC>=463)   
                drawLine(408,18,408,14);
            if (Bat2_ADC>=497)
                drawLine(409,18,409,14);                
            if (Bat2_ADC>=531 )
                drawLine(412,18,412,14);    
            if (Bat2_ADC>=565 )
                drawLine(413,18,413,14);    
            if (Bat2_ADC>=599 )
                drawLine(416,18,416,14);
            if (Bat2_ADC>=633 )
                drawLine(417,18,417,14);                      
            }
        if (Bat2_ADC<Bat1_ADC)                   // Bat2 OFF Draw for BAT1 // <100
            {
            if (Bat1_ADC>=463)   
                drawLine(408,18,408,14);
            if (Bat1_ADC>=497)
                drawLine(409,18,409,14);                
            if (Bat1_ADC>=531 )
                drawLine(412,18,412,14);    
            if (Bat1_ADC>=565 )
                drawLine(413,18,413,14);    
            if (Bat1_ADC>=599 )
                drawLine(416,18,416,14);
            if (Bat1_ADC>=633 )
                drawLine(417,18,417,14);                 
            }        
        }
    if ((USB_ADC> 300)&& Flag_SPI_USB)
        {
        draw_Plug_bat();
        }
    Flag_SPI_USB=false;             // To Read AGAIN!
    Flag_SPI_Bat=false; 
    return;
    }
else
    {
    return;
    }
}
void draw_Plug_bat(void)
{
    setColor(VGA_BLACK);                // Back to Black Set color to all Draw, Fill and Print(letters)   
    fillRect(404,11,420,21);
    fillRect(420,14,424,18); 
    setColor_1(217,217,217);               // Grey Set color to all Draw, Fill and Print(letters)
    fillRect(404,15,413,18);
    fillRect(413,14,418,18);
    fillRect(410,12,413,20);
    drawLine(409,13,409,19);
    drawLine(408,14,408,18);  
    setColor(VGA_BLACK);                // Back to Black Set color to all Draw, Fill and Print(letters)   
    drawLine(413,16,418,16); 
    drawLine(404,15,404,18); 
    drawLine(404,18,407,18);
}


uint8_t get_Tr_Power(void)
{
    char error_flag;
    
    Stack[0]=0;             // Stack Global Problem with Optimiser
    Stack[1]=0;
    Stack[2]=0;
    Stack[3]=0;
    Stack[4]=0;
    Stack[5]=0;
    error_flag=0;

    i=0;
    char_count=0;
    key_int=0;
    while(true)                         // Wait for ANY key
    {
        delay_ms(100);  
        if ((key_int >= 0x30)&& (key_int <= 0x39))
        {
            printChar(key_int, x_pos,y_pos);
            x_pos +=18;
            if ((key_int >= 0x30)&& (key_int <= 0x39))
               Stack[i]= key_int & 0x0F;
            char_count++;
            i++;
            if(i>=2)
                break;
            delay_ms(100);
        }
  
         if (key_int == 0x0A)                    
            break;                  
    }
    Num_ret=0;
    if (char_count == 2)
    {
        Num_ret+=(Stack[0]& 0x0F)*10;
        Num_ret+=(Stack[1]& 0x0F);
    }
    if (char_count == 1)
    {
        Num_ret+=(Stack[0]& 0x0F); 
    }
    if ((Num_ret<0)|| (Num_ret>63))
    {
        print("Error Try Again                 ", 10, 25, 0);
        print("                     ", 10,51 , 0);
        print("                  ", x_pos_back,y_pos_back , 0);
        Num_ret=0;
        while(true)                         // Wait for ANY key
        {
            delay_ms(100);  
            if (key_int != 0x00)
            {
            break;  
            }
        }  
    }
    delay_ms(100);  
    return(Num_ret);
}

void Set_RF(void)
{
    double test_deb, test_deb_2;
    attenuate[0]=0;
    attenuate[1]=0;   
    attenuate[2]=0;
    attenuate[3]=0;
    attenuate[4]=0;
    attenuate[5]=0;
    attenuate[6]=0;
    setColor(VGA_BLACK);
    setFont(Arial_round_16x24);
    setBackColor_1(217,217,217);  
    if ((ONOFF_Chan[1]==0) && (ONOFF_Chan[2]==0)&& (ONOFF_Chan[3]==0)&& (ONOFF_Chan[4]==0) )
        {
        print("ALL Ports are OFF          ", 10, 260, 0);                  // Message Error  
        delay_ms(1000); 
        print("                           ", 10, 260, 0);  
        All_OFF=1;                                              // ALL Ports are OFF
        return;
        }
    else
        {
        print("DATA Transfer to RF modules", 10, 260, 0);                  // Message Error
        All_OFF=0;                                              // ALL Ports are NOT OFF
        }

// dBmPower   
    for (channel=1; channel < 5; channel++) 
        {
        if (ONOFF_Chan[channel]!=0)
            {
            send_SPI_settings(channel,Freq_IN[channel],dBmPower[channel]);         // Send to 67K40 settings (Power Hanging)  
            delay_ms(100);                          // 3X TIMES WHY to be checked!!!!
            send_SPI_settings(channel,Freq_IN[channel],dBmPower[channel]);         // Send to 67K40 settings (Power Hanging)    
            delay_ms(100);
//            send_SPI_settings(channel,Freq_IN[channel],dBmPower[channel]);         // Send to 67K40 settings (Power Hanging)
            if (Freq_IN[channel] == 0)                                           
                {
                    Trans_ONOFF_Chan[channel]=0;                                // Transmit OFF
                    LED_CHAN_DE_Activate(channel);                              // LED OFF if Frequency EQ to 0
                    setColor(VGA_YELLOW);     
                    if (channel==1)
                        fillCircle( 430,106,8);  	// Ch. 1
                    if (channel==2)
                        fillCircle( 430,133,8);  	// Ch. 2
                    if (channel==3)                    
                       fillCircle( 430,160,8);  	// Ch. 3
                    if (channel==4)                     
                        fillCircle( 430,187,8);  	// Ch. 4  
                   // if (channel==5)  
                     //   fillCircle( 430,214,8);  	// Ch. 5
                    //if (channel==6)
                      //  fillCircle( 430,241,8);  	// Ch. 6
                }
                else
                {
                    Trans_ONOFF_Chan[channel]=1;                                // Transmit ON
                    LED_CHAN_Activate(channel); 
                    setColor(VGA_GREEN);     
                    if (channel==1)
                        fillCircle( 430,106,8);  	// Ch. 1
                    if (channel==2)
                        fillCircle( 430,133,8);  	// Ch. 2
                    if (channel==3)                    
                       fillCircle( 430,160,8);  	// Ch. 3
                    if (channel==4)                     
                        fillCircle( 430,187,8);  	// Ch. 4  
                   // if (channel==5)  
                     //   fillCircle( 430,214,8);  	// Ch. 5
                    //if (channel==6)
                      //  fillCircle( 430,241,8);  	// Ch. 6
                }
            }

            delay_ms(500);  // Shorten DELAY???
        }
    setColor(VGA_BLACK);
    setBackColor_1(217,217,217);  
    print("END of DATA transfer         ", 10, 260, 0);                  // Message Error  
    delay_ms(1000); 
    print("                           ", 10, 260, 0);   
    return;
}
// Compiler Bugs continued
void Save_New_Project(void)         //  for the whole procedure 
{
    int i_SP, ld_Wd;
    My_SPI_EEPROM_Read(0x00,0x1B, What_getEEPROMdata,1);        // Last entered Project Number in EEPROM 00 1B 
    Lat_ProjNum=What_getEEPROMdata[0]+1;                        // The Latest Project Number + 1
    W_Data[0]=(Lat_ProjNum & 0xFF);
                LATEbits.LATE9=1;                   // Slave EEPROM Select OFF
                LATFbits.LATF0=1;                   // Slave RTCC Select OFF    
                LATFbits.LATF3=1;                   // Slave 67K40 Select OFF     
                LATFbits.LATF12=1;                  // Slave 25Q10 Select OFF
    delay_ms(5);
    My_SPI_EEPROM_Write(0x00,0x1B, W_Data, 1);          // Project Number# in 00 1B 
    delay_ms(5);
    ld_Wd=1;
    if (Lat_ProjNum <= MAX_PROJECT)
        {
        for (i_SP = 1; i_SP <= 6; i_SP++)                // Print last entered values 
            {    
            W_Data[ld_Wd]=(Freq_IN[i_SP]&0xFF);
            W_Data[ld_Wd+1]=((Freq_IN[i_SP]>>8)&0xFF);  
            W_Data[ld_Wd+2]=dBmPower[i_SP]; 
            ld_Wd +=3;
            }
        True_ProjNum=Get_True(Lat_ProjNum);
        addr_Num=True_ProjNum * 10 + (True_ProjNum+1)*10;                     // Calculate the Project's address 
        Adr_Arr[1]=(addr_Num&0xFF);                                         //extract first byte
        Adr_Arr[0]=((addr_Num>>8)&0xFF);
                LATEbits.LATE9=1;                   // Slave EEPROM Select OFF
                LATFbits.LATF0=1;                   // Slave RTCC Select OFF    
                LATFbits.LATF3=1;                   // Slave 67K40 Select OFF     
                LATFbits.LATF12=1;                  // Slave 25Q10 Select OFF
        delay_ms(20);
        My_SPI_EEPROM_Write(Adr_Arr[0],Adr_Arr[1], W_Data,20);  
        delay_ms(20);
        My_SPI_EEPROM_Read(Adr_Arr[0],Adr_Arr[1], What_getEEPROMdata,20);        // DEBUGING ERASE AFTER
        addr_Num +=1;                
        for (i_SP = 1; i_SP <= 6; i_SP++)               // Print last entered values 
            {
            Adr_Arr[1]=(addr_Num&0xFF);                                         //extract first byte
            Adr_Arr[0]=((addr_Num>>8)&0xFF);                                    //extract second byte
            My_SPI_EEPROM_Read(Adr_Arr[0],Adr_Arr[1], What_getEEPROMdata,2);        
            Freq_IN[i_SP]=(What_getEEPROMdata[1]<<8)+What_getEEPROMdata[0];  // Load stored Values
            addr_Num+=2;
            Adr_Arr[1]=(addr_Num&0xFF);                                             //extract first byte
            Adr_Arr[0]=((addr_Num>>8)&0xFF);                                        //extract second byte
            My_SPI_EEPROM_Read(Adr_Arr[0],Adr_Arr[1], What_getEEPROMdata,1);        
            dBmPower[i_SP]=What_getEEPROMdata[0];                 
            addr_Num+=1;
            }      
        }
    else
        {
        setColor(VGA_RED);
        setBackColor_1(217,217,217);  
        print("Maximum Number of Projects!", 10, 260, 0);                  // Message Error  
        delay_ms(1500); 
        print("                           ", 10, 260, 0);           
        }        
}

void Save_Project(void)
{
    int i_SP,addr_Num_SP, ld_Wd;
    W_Data[0]=(Curr_ProjNum & 0xFF); 
    ld_Wd=1;    
    for (i_SP = 1; i_SP <= 6; i_SP++)                                   // Print last entered values 
        {
        W_Data[ld_Wd]=(Freq_IN[i_SP]&0xFF);
        W_Data[ld_Wd+1]=((Freq_IN[i_SP]>>8)&0xFF);  
        W_Data[ld_Wd+2]=dBmPower[i_SP]; 
        ld_Wd +=3;
        } 
    True_ProjNum=Get_True(Curr_ProjNum);
    addr_Num=True_ProjNum * 10 + (True_ProjNum+1)*10;                   // Current project Calculate the Project's address 
    Adr_Arr[1]=(addr_Num&0xFF);                                         //extract first byte
    Adr_Arr[0]=((addr_Num>>8)&0xFF);
                LATEbits.LATE9=1;                   // Slave EEPROM Select OFF
                LATFbits.LATF0=1;                   // Slave RTCC Select OFF    
                LATFbits.LATF3=1;                   // Slave 67K40 Select OFF     
                LATFbits.LATF12=1;                  // Slave 25Q10 Select OFF
    delay_ms(20);
    My_SPI_EEPROM_Write(Adr_Arr[0],Adr_Arr[1], W_Data,20);  
    delay_ms(20);
    My_SPI_EEPROM_Read(Adr_Arr[0],Adr_Arr[1], What_getEEPROMdata,20);        // DEBUGING ERASE AFTER              
    addr_Num +=1;                
        for (i_SP = 1; i_SP <= 6; i_SP++)               // Print last entered values 
            {
            Adr_Arr[1]=(addr_Num&0xFF);                                         //extract first byte
            Adr_Arr[0]=((addr_Num>>8)&0xFF);                                    //extract second byte
            My_SPI_EEPROM_Read(Adr_Arr[0],Adr_Arr[1], What_getEEPROMdata,2);        
            Freq_IN[i_SP]=(What_getEEPROMdata[1]<<8)+What_getEEPROMdata[0];  // Load stored Values
            addr_Num+=2;
            Adr_Arr[1]=(addr_Num&0xFF);                                             //extract first byte
            Adr_Arr[0]=((addr_Num>>8)&0xFF);                                        //extract second byte
            My_SPI_EEPROM_Read(Adr_Arr[0],Adr_Arr[1], What_getEEPROMdata,1);        
            dBmPower[i_SP]=What_getEEPROMdata[0];                 
            addr_Num+=1;
            }     

    //    addr_Num_SP=next_page_index()-1; // DO WE NEED THAT??
//    addr_Num=Curr_ProjNum*13-3; 
}


void Channels_In(void)
{
 uint8_t stay_in_channels; 
 int i_ch_In;
//###########========================== CHANNELS  Start
    stay_in_channels=0;
    y_pos=77;   //62;
    fillScr_1(217,217,217);             //(VGA_PURPLE);
    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  

    setFont(SmallFont);         // SmallFont_8x12  // <------ 
//    print("-",430, 10,0);                   // RESTORE IT IF SPI TO 25Q10 WORK
//    print("-",435, 10,0);
//    print("-",442, 10,0);
//    print("%",449, 10,0);

    setColor(VGA_RED);             // Set color to all Draw, Fill and Print(letters)
    fillRect(0,296,480,319);
    setColor(VGA_WHITE);            // Set color to all Draw, Fill and Print(letters)
    setBackColor(VGA_RED);  
    setFont(arial_8x16); //Arial_round_16x24);         // Back to Arial 16X24 // <------     
    print(" CHANNELS (F1)   PROJECTS (F2)   SETTINGS (F3)   HELP (F4)", 2, 302, 0); // Hor,Vert,Rotate

    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
    setFont(Arial_round_16x24);
    Run_Stop_Marker=0;  
    

    
 
    while(true)   
    {        
        //<-------------
        draw_battery();
        x_pos=10;  
        setFont(Arial_round_16x24);// Start Position Showing Channel & Frequency
        print("CHANNELS                  ", 7, 25, 0); // Hor,Vert,Rotate Enter Channel to set (1~6)
        drawLine(0,49, 479,49);  
        setFont(arial_8x16); //
        print("               Freq.         Power          Mode  Module", 10, 53, 0);
        print("           137 ~ 6000MHz      dBm                Available", 10, 77, 0);
        print("Project No.", 187, 25, 0);
        //projectNum=flash_read_word(next_page_index()-13);           // Find the last entered ProjectNum
        printNumI(Curr_ProjNum, 268, 25, 3, ' ');               // old projectNum
        setColor_1(174,174,174);            // 
        fillRect(0,93,480,120);             // 1st Dark Grey fill Rect
        setColor(VGA_BLACK); 
        drawLine(0,93, 479,93);  
        setBackColor_1(174,174,174);        // Dark Grey
        setFont(Arial_round_16x24);
        print("CH1                   CW ", 7, 97, 0);
        //print("2800.2   20     CW",103,97,0);
        setBackColor_1(217,217,217);        // Light Grey   
        print("CH2                   CW ", 7, 123, 0);
        setColor_1(174,174,174);  
        fillRect(0,148,480,174);            // 2nd Dark Grey fill Rect
        setBackColor_1(174,174,174);        // Dark Grey
        setColor(VGA_BLACK); 
        print("CH3                   CW ", 7, 151, 0);        
        setBackColor_1(217,217,217);        // Light Grey   
        print("CH4                   CW ", 7, 178, 0);
        setColor_1(174,174,174);  
        fillRect(0,202,480,228);            // 3rd Dark Grey fill Rect
        setBackColor_1(174,174,174);        // Dark Grey  
        setColor(VGA_BLACK); 
        print("CH5  NOT Installed    CW ", 7, 205, 0);          
        setBackColor_1(217,217,217);        // Light Grey   
        print("CH6  NOT Installed    CW ", 7, 232, 0);  
        drawLine(0,259, 479,259);           // Last Bottom Line        
        setColor(VGA_RED);             // Set colour to all Draw, Fill and Print(letters)
        fillRect(0,296,480,319);            // RED BOX BOTTOM
        setColor(VGA_WHITE);            // Set colour to all Draw, Fill and Print(letters)
        setBackColor(VGA_RED);  
        setFont(arial_8x16); //Arial_round_16x24);         // Back to Arial 16X24 // <------  
        if (Run_Stop_Marker == 0)                          // if We are in RUN or STOP condition
            print(" RUN (F1)     SAVE (F2)     SAVE_NEW(F3)     HOME (F4)", 2, 302, 0);            // Hor,Vert,Rotate  
        else
            print("STOP (F1)     SAVE (F2)     SAVE_NEW(F3)     HOME (F4)", 2, 302, 0);            // Hor,Vert,Rotate 
        for (i_ch_In=1; i_ch_In < 5; i_ch_In++)     
            {
             if (Trans_ONOFF_Chan[i_ch_In] == 0)                                           
                {
                    setColor(VGA_YELLOW);     
                    if (i_ch_In==1)
                        fillCircle( 430,106,8);  	// Ch. 1
                    if (i_ch_In==2)
                        fillCircle( 430,133,8);  	// Ch. 2
                    if (i_ch_In==3)                    
                       fillCircle( 430,160,8);  	// Ch. 3
                    if (i_ch_In==4)                     
                        fillCircle( 430,187,8);  	// Ch. 4  
                    setColor(VGA_RED); 
                    
                   
                    //if (i_ch_In==5)  
                        fillCircle( 430,214,8);  	// Ch. 5
                   // if (i_ch_In==6)
                        fillCircle( 430,241,8);  	// Ch. 6
                }
                else
                {
                    setColor(VGA_GREEN);     
                    if (i_ch_In==1)
                        fillCircle( 430,106,8);  	// Ch. 1
                    if (i_ch_In==2)
                        fillCircle( 430,133,8);  	// Ch. 2
                    if (i_ch_In==3)                    
                       fillCircle( 430,160,8);  	// Ch. 3
                    if (i_ch_In==4)                     
                        fillCircle( 430,187,8);  	// Ch. 4  
                    setColor(VGA_RED); 
                   
                   
                   // if (i_ch_In==5)  
                        fillCircle( 430,214,8);  	// Ch. 5
                  //  if (i_ch_In==6)
                        fillCircle( 430,241,8);  	// Ch. 6
                }
            }
//        setColor(VGA_YELLOW);            // Set colour to all Draw, Fill and Print(letters)
//        fillCircle( 430,106,8);
//        fillCircle( 430,133,8);
//        fillCircle( 430,160,8);
//        fillCircle( 430,187,8);
//        fillCircle( 430,214,8);
//        fillCircle( 430,241,8);
        YB_posX=1;
        YB_posY=1;
        YB_X1=102;
        YB_Y1=94;
        YB_X2=199;
        YB_Y2=119;
//<======== Print Stored Values 
        My_SPI_EEPROM_Read(0x00,0x1B, What_getEEPROMdata,1);        // Last entered Project Number in EEPROM 00 1B 
        projectNum=What_getEEPROMdata[0]+1;                        // The Latest Project Number + 1 // Find the last entered ProjectNum
        // Read EEPROM and Show!
//        addr_Num=Lat_ProjNum * 10 + (Lat_ProjNum+1)*10;                     // Calculate the Project's address 
//        addr_Num +=1;                         
//        for (i_ch_In = 1; i_ch_In <= 6; i_ch_In++)               // Print last entered values 
//            {
//            Adr_Arr[1]=(addr_Num&0xFF);                                         //extract first byte
//            Adr_Arr[0]=((addr_Num>>8)&0xFF);                                    //extract second byte
//            My_SPI_EEPROM_Read(Adr_Arr[0],Adr_Arr[1], What_getEEPROMdata,2);        
//            Freq_IN[i_ch_In]=(What_getEEPROMdata[1]<<8)+What_getEEPROMdata[0];  // Load stored Values
//            addr_Num+=2;
//            Adr_Arr[1]=(addr_Num&0xFF);                                             //extract first byte
//            Adr_Arr[0]=((addr_Num>>8)&0xFF);                                        //extract second byte
//            My_SPI_EEPROM_Read(Adr_Arr[0],Adr_Arr[1], What_getEEPROMdata,1);        
//            dBmPower[i_ch_In]=What_getEEPROMdata[0];                 
//            addr_Num+=1;
//            }
        setColor(VGA_BLACK); 
        setFont(Arial_round_16x24);    
        y_pos_prt=97;
        for (i_test_flash = 1; i_test_flash <= 4; i_test_flash++)               // Print last entered values 
            {
            if ((i_test_flash==1)||(i_test_flash==3))
                setBackColor_1(174,174,174);                                    // Dark Grey
           // if ((i_test_flash==2)||(i_test_flash==4)||(i_test_flash==6))
             if ((i_test_flash==2)||(i_test_flash==4))
                setBackColor_1(217,217,217);                                    // Light Grey    
            printNumI(Freq_IN[i_test_flash]/10,111, y_pos_prt, 4, ' ');     // Print Frequency NO DOT POINT!!!
            printNumI(dBmPower[i_test_flash], 230, y_pos_prt, 3, ' ');      // Print dBm 
            y_pos_prt+=27;
            addr_Num+=2;
            }          
        setColor(VGA_YELLOW); 
        drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2);          //YELLOW_BOX 1
        
        while(true)                                     // Enter Parameters
            {            
            delay_ms(100); 
            draw_battery();
// F1 RUN selected channels  or STOP (here the CHANGES)  place marker         
            if (key_int == 59)                                                  
                {
                if (Run_Stop_Marker == 0)
                    {
                    Run_Stop_Marker=1;                    
                    Set_RF(); 
                    if (All_OFF==0)
                        test_RF_1();
                    key_int =0;
                    }
                else
                    {
                    Run_Stop_Marker=0;                    
                    STOP_RF();
                    test_RF_2();
                    stay_in_channels=0;
                    key_int =0;
                    }
                }
// PAUSE selected channels
            if ((key_int == 80) && (Run_Stop_Marker == 1))      // PAUSE button
                {
                Run_Stop_Marker=0;                    
                STOP_RF();
                test_RF_2();
                stay_in_channels=0;
                key_int =0;                
                }
// PAUSE for RUN selected channels
            if ((key_int == 80) && (Run_Stop_Marker == 0))  
                {
                Run_Stop_Marker=1;                    
                Set_RF(); 
                if (All_OFF==0)
                    test_RF_1();
                key_int =0;                
                }
                
// F2 or SAVE selected channels And Save button           
            if ((key_int == 60)|| (key_int==83))            //                                               
                {                
                    Save_Project();            // Save Project
                    setColor(VGA_BLACK);
                    setBackColor_1(217,217,217);  
                    print("Project Updated            ", 10, 260, 0);                  // Message Error  
                    delay_ms(600); 
                    print("                           ", 10, 260, 0);     
                    break;
                } 
            
            if ((key_int == 61))            //                                               
                {                
                Save_New_Project();                                          // Save Project  
//                My_SPI_EEPROM_Read(0x00,0x1B, What_getEEPROMdata,1);        // Last entered Project Number in EEPROM 00 1B 
//                Lat_ProjNum=What_getEEPROMdata[0]+1;                        // The Latest Project Number + 1
//                addr_Num=Flash_Back[0]*10+(Flash_Back[0]-1)*3;                               //   
                if (Lat_ProjNum <= MAX_PROJECT)                                                 // 
                    {
//                    Lat_ProjNum =flash_read_word(0);        //flash_read_word(next_page_index()-13); //xx Flash           // Find the last entered ProjectNum 
                    Curr_ProjNum=Lat_ProjNum;                     
                    setColor(VGA_BLACK);
                    setBackColor_1(217,217,217);  
                    print("New Project SAVED          ", 10, 260, 0);                  // Message Error  
                    delay_ms(600); 
                    print("                           ", 10, 260, 0);           
                    break;
                    }
                }             
           
// F4 HOME goto home            
            if ((key_int == 62)||(key_int ==27))                                                 
                {                
                    // Go to HOME
                stay_in_channels=1;
                break;
                }
// RF ON-OFF channels            
            if (key_int == 82 )                                                  
                {                
                Set_ON_OFF();                                                 // Turn ON OF channels
                if (key_int == 27)
                    {
                    stay_in_channels=1;
                    break;                  
                    }
                if (key_int == 62)
                    {
                    stay_in_channels=0;
                    break;                  
                    }
                }            
// Left or Right
            if (((key_int == 108)&&  (YB_posX == 1)) || ((key_int == 114)&&  (YB_posX == 2)))       // Left or Right stay in position
                {
                setColor(VGA_YELLOW); 
                drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2);  
                }
// Left
            if ((key_int == 108)&&  (YB_posX == 2))                             // Left
                {
                if (YB_posY ==1 || YB_posY ==3 || YB_posY ==5)                  // Erase YB 
                    {
                    setColor_1(174,174,174);                                    // Dark Grey
                    drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2);
                    }
                if (YB_posY ==2 || YB_posY ==4 || YB_posY ==6)                  // Erase YB 
                    {
                    setColor_1(217,217,217);                                    // Light Grey
                    drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2);
                    }                
                YB_X1 -=113;                                                    // DE-crease YB coordinates
                YB_X2 -=113;
                setColor(VGA_YELLOW);                                           // Draw new YB
                drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2); 
                YB_posX=1;
                }
// RIGHT
            if ((key_int == 114)&&  (YB_posX == 1))                             // RIGHT
                {
                if (YB_posY ==1 || YB_posY ==3 || YB_posY ==5)                  // Erase YB 
                    {
                    setColor_1(174,174,174);                                    // Dark Grey
                    drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2);
                    }
                if (YB_posY ==2 || YB_posY ==4 || YB_posY ==6)                  // Erase YB 
                    {
                    setColor_1(217,217,217);                                    // Light Grey
                    drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2);
                    }                
                YB_X1 +=113;                                                    // Increase YB coordinates
                YB_X2 +=113;
                setColor(VGA_YELLOW);                                           // Draw new YB
                drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2);
                YB_posX=2;
                }            
//UP & Down <============
            if ((key_int == 80) && (Run_Stop_Marker == 1))      // PAUSE button
                {
                Run_Stop_Marker=0;                    
                STOP_RF();
                test_RF_2();
                stay_in_channels=0;
                key_int =0;                
                }
// PAUSE for RUN selected channels
            if ((key_int == 80) && (Run_Stop_Marker == 0))  
                {
                Run_Stop_Marker=1;                    
                Set_RF(); 
                if (All_OFF==0)
                    test_RF_1();
                key_int =0;                
                }
                
// F2 or SAVE selected channels And Save button           
            if ((key_int == 60)|| (key_int==83))            //                                               
                {                
                    Save_Project();            // Save Project
                    setColor(VGA_BLACK);
                    setBackColor_1(217,217,217);  
                    print("Project Updated            ", 10, 260, 0);                  // Message Error  
                    delay_ms(600); 
                    print("                           ", 10, 260, 0);     
                    break;
                } 
            
            if ((key_int == 61))            //                                               
                {                
                Save_New_Project();                                          // Save Project //xx Flash
                addr_Num=Flash_Back[0]*10+(Flash_Back[0]-1)*3;                               //xx Flash   
                if (addr_Num <= MAX_PROJECT)                                                 //xx Flash
                    {
                    Lat_ProjNum =flash_read_word(0);        //flash_read_word(next_page_index()-13); //xx Flash           // Find the last entered ProjectNum 
                    Curr_ProjNum=Lat_ProjNum;                     
                    setColor(VGA_BLACK);
                    setBackColor_1(217,217,217);  
                    print("New Project SAVED          ", 10, 260, 0);                  // Message Error  
                    delay_ms(600); 
                    print("                           ", 10, 260, 0);           
                    break;
                    }
                }             
           
// F4 HOME goto home            
            if ((key_int == 62)||(key_int ==27))                                                 
                {                
                    // Go to HOME
                stay_in_channels=1;
                break;
                }
// RF ON-OFF channels            
            if (key_int == 82 )                                                  
                {                
                Set_ON_OFF();                                                 // Turn ON OF channels
                if (key_int == 27)
                    {
                    stay_in_channels=1;
                    break;                  
                    }
                if (key_int == 62)
                    {
                    stay_in_channels=0;
                    break;                  
                    }
                }            
// Left or Right
            if (((key_int == 108)&&  (YB_posX == 1)) || ((key_int == 114)&&  (YB_posX == 2)))       // Left or Right stay in position
                {
                setColor(VGA_YELLOW); 
                drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2);  
                }
// Left
            if ((key_int == 108)&&  (YB_posX == 2))                             // Left
                {
                if (YB_posY ==1 || YB_posY ==3 || YB_posY ==5)                  // Erase YB 
                    {
                    setColor_1(174,174,174);                                    // Dark Grey
                    drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2);
                    }
                if (YB_posY ==2 || YB_posY ==4 || YB_posY ==6)                  // Erase YB 
                    {
                    setColor_1(217,217,217);                                    // Light Grey
                    drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2);
                    }                
                YB_X1 -=113;                                                    // DE-crease YB coordinates
                YB_X2 -=113;
                setColor(VGA_YELLOW);                                           // Draw new YB
                drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2); 
                YB_posX=1;
                }
// RIGHT
            if ((key_int == 114)&&  (YB_posX == 1))                             // RIGHT
                {
                if (YB_posY ==1 || YB_posY ==3 || YB_posY ==5)                  // Erase YB 
                    {
                    setColor_1(174,174,174);                                    // Dark Grey
                    drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2);
                    }
                if (YB_posY ==2 || YB_posY ==4 || YB_posY ==6)                  // Erase YB 
                    {
                    setColor_1(217,217,217);                                    // Light Grey
                    drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2);
                    }                
                YB_X1 +=113;                                                    // Increase YB coordinates
                YB_X2 +=113;
                setColor(VGA_YELLOW);                                           // Draw new YB
                drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2);
                YB_posX=2;
                }            
//UP & Down <============
            if (((key_int == 117)&&  (YB_posY == 1)) || ((key_int == 100)&& (YB_posY == 4)))       // UP or DOWN stay in position
                {
                setColor(VGA_YELLOW); 
                drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2);  
                }
 // UP
            if ((key_int == 117) && ((YB_posY == 2) || (YB_posY ==3)|| (YB_posY ==4)|| (YB_posY ==5)|| (YB_posY ==6)))             // Up
                {
                if (YB_posY ==1 || YB_posY ==3 || YB_posY ==5)                  // Erase YB 
                    {
                    setColor_1(174,174,174);                                    // Dark Grey
                    drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2);
                    }
                if (YB_posY ==2 || YB_posY ==4 || YB_posY ==6)                  // Erase YB 
                    {
                    setColor_1(217,217,217);                                    // Light Grey
                    drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2);
                    }                
                YB_Y1 -=27;                                                    // DE-crease YB coordinates
                YB_Y2 -=27;
                setColor(VGA_YELLOW);                                           // Draw new YB
                drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2); 
                YB_posY -=1;
                }           

// DOWN
            if ((key_int == 100) && ((YB_posY == 1)||(YB_posY == 2) ||(YB_posY == 3)))            // DOWN
                {
                if (YB_posY ==1 || YB_posY ==3 || YB_posY ==5)                  // Erase YB 
                    {
                    setColor_1(174,174,174);                                    // Dark Grey
                    drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2);
                    }
                if (YB_posY ==2 || YB_posY ==4 || YB_posY ==6)                  // Erase YB 
                    {
                    setColor_1(217,217,217);                                    // Light Grey
                    drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2);
                    }                
                YB_Y1 +=27;                                                    // DE-crease YB coordinates
                YB_Y2 +=27;
                setColor(VGA_YELLOW);                                           // Draw new YB
                drawRoundRect(YB_X1,YB_Y1,YB_X2,YB_Y2); 
                YB_posY +=1;
                } 
            
            if (((key_int >= 0x30)&& (key_int <= 0x39))||(key_int == 10)||(key_int == 45))       // ENTER to enter values any key 0-9
                {
                setBackColor_1(217,217,217);          
                print("                                ", 10, 260, 0);          // Clear the Message Area       
                if (YB_posY ==1 || YB_posY ==3 || YB_posY ==5)                  //   
                    {
                    setBackColor_1(174,174,174);                                    // Dark Grey
                    }
                if (YB_posY ==2 || YB_posY ==4 || YB_posY ==6)                  //  
                    {
                    setBackColor_1(217,217,217);                                    // Light Grey
                    }  

                if (YB_posX==1)
                    {
                    x_pos=YB_X1 +10;            // old 1
                    y_pos=YB_Y1 +3;
                    setColor(VGA_BLACK);
                    setFont(Arial_round_16x24);
                    print("---   ", x_pos, y_pos, 0);
                    Freq_IN[YB_posY] = get_Freq();
//                    tO_MOUNI_SOY_MESA[YB_posY]=Num_ret;

                    }
                if (YB_posX==2)
                    {                    
                    x_pos=YB_X1 +32;
                    y_pos=YB_Y1 +3;
                    setColor(VGA_BLACK);
                    setFont(Arial_round_16x24);
                    print(" ~  ", x_pos-20, y_pos, 0);      // Changed (-20) on 18-6-2019
                    dBmPower[YB_posY] = get_dBmP();                      
                    }                
                }  
//<============            
            }
            setColor(VGA_BLACK);
            setBackColor_1(217,217,217);          
            print("                           ", 10, 260, 0); 
            if (stay_in_channels!=0) 
                {
// F4 Home    
// Go to HOME
                show_scrn=0;        // To show Screen it HAS to be cleared in every Page
                key_int=0;
                break;               
                }
    }     //<----------------------    
}
void Project_In(void)
{
    int i_Pr_In,i_count_Pr;
    int x_pos_Pr, y_pos_Pr;
    uint8_t h_check_flag_Pr,error_flag_Pr; 
    char Pr_chars[3];
    h_check_flag_Pr=0;
    error_flag_Pr=0;
    i_count_Pr=0;
    fillScr_1(217,217,217);             //(VGA_PURPLE);
    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
//    draw_battery();                   // RESTORE IT IF SPI TO 25Q10 WORK
//    draw_Plug_bat();                  // If plugged to USB 
    setFont(SmallFont);             // SmallFont_8x12  // <------ 
//    print("-",430, 10,0);                   // RESTORE IT IF SPI TO 25Q10 WORK
//    print("-",435, 10,0);
//    print("-",442, 10,0);
//    print("%",449, 10,0);
    setColor(VGA_RED);              // Set color to all Draw, Fill and Print(letters)
    fillRect(0,296,480,319);
    setColor(VGA_WHITE);            // Set color to all Draw, Fill and Print(letters)
    setBackColor(VGA_RED);  
    setFont(arial_8x16);            //Arial_round_16x24);         // Back to Arial 16X24 // <------     
    print(" LOAD (F1)           ERASE_ALL(F3)           HOME (F4)", 2, 302, 0); // Hor,Vert,Rotate

    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
    setFont(Arial_round_16x24);   
    print("PROJECTS", 7, 25, 0); // Hor,Vert,Rotate Enter Channel to set (1~6)
    drawLine(0,49, 479,49); 
//    Debug_index=next_page_index();            // xx Flash
    My_SPI_EEPROM_Read(0x00,0x1B, What_getEEPROMdata,1);        // Last entered Project Number in EEPROM 00 1B 
    Lat_ProjNum=What_getEEPROMdata[0];                        // The Latest Project Number 
//    Lat_ProjNum =flash_read_word(0);            // xx Flash  //flash_read_word(Debug_index-13);           // Find the last entered ProjectNum 
    print("Available Projects", 22, 97, 0); //     
    printNumI(Lat_ProjNum, 312, 97, 2, ' ');  
    printNumI(Curr_ProjNum, 312, 123, 2, ' ');      //Must be BEFORE print("Current Project")!!!
    print("Current Project", 22, 123, 0); //         

    
    while(true)                                     // Enter Parameters
        {
        delay_ms(100); 
        draw_battery();
// F4 HOME goto home            
        if ((key_int == 62) ||(key_int ==27))                                                  
            {                
            // Go to HOME
            key_int=0;
            show_scrn=0;        // To show Screen it HAS to be cleared in every Page
            break;
            } 
// F3   CLEAR ALL PROJECTS
        if (key_int == 61)                                                   
            {                
            print("Erase All Projects?", 22, 149, 0); //  
            print("Enter for OK - ESC for Cancel", 22, 175, 0); // 
            while (true)
            {
                delay_ms(100); 
                if (key_int == 27)          // ESCAPE - CANCEL
                {                   
                break;                    
                }
                if (key_int == 10)          // ENTER OK CLEAR
                {
                W_Data[0]=0x01;         // Project Number  
                W_Data[1]=0x40;         // Freq #1 -A 8000
                W_Data[2]=0x1F;         // Freq #1 -B  
                W_Data[3]=0x00;         // dBm #1
                W_Data[4]=0x40;         // Freq #2 -A
                W_Data[5]=0x1F;         // Freq #2 -B
                W_Data[6]=0x00;         // dBm #2
                W_Data[7]=0x40;         // Freq #3 -A
                W_Data[8]=0x1F;         // Freq #3 -B
                W_Data[9]=0x00;         // dBm #3  
                W_Data[10]=0x40;        // Freq #4 -A 8000
                W_Data[11]=0x1F;        // Freq #4 -B  
                W_Data[12]=0x00;        // dBm #4
                W_Data[13]=0x40;        // Freq #5 -A
                W_Data[14]=0x1F;        // Freq #5 -B
                W_Data[15]=0x00;        // dBm #5
                W_Data[16]=0x40;        // Freq #6 -A
                W_Data[17]=0x1F;        // Freq #6 -B
                W_Data[18]=0x00;        // dBm #6  
                W_Data[19]=0b00111111;  // Channels ON 
                LATEbits.LATE9=1;                   // Slave EEPROM Select OFF
                LATFbits.LATF0=1;                   // Slave RTCC Select OFF    
                LATFbits.LATF3=1;                   // Slave 67K40 Select OFF     
                LATFbits.LATF12=1;                  // Slave 25Q10 Select OFF
                delay_ms(20);
                My_SPI_EEPROM_Write(0x00,0x1E, W_Data, 20);
                LATEbits.LATE9=1;                   // Slave EEPROM Select OFF
                LATFbits.LATF0=1;                   // Slave RTCC Select OFF    
                LATFbits.LATF3=1;                   // Slave 67K40 Select OFF     
                LATFbits.LATF12=1;                  // Slave 25Q10 Select OFF
                delay_ms(20);
                W_Data[0]=0x01;         
                My_SPI_EEPROM_Write(0x00,0x1B, W_Data, 1);                      // Project #1 in 00 1B 
                delay_ms(20);
                W_Data[0]=0x01; 
                My_SPI_EEPROM_Read(0x00,0x1B, What_getEEPROMdata,1);            // Last entered Project Number in EEPROM 00 1B 
                Curr_ProjNum=1;
                My_SPI_EEPROM_Read(0x00,0x1B, What_getEEPROMdata,1);  
                addr_Num=Curr_ProjNum * 10 + (Curr_ProjNum+1)*10;               // Calculate the Project's address 
                addr_Num +=1;                         
                for (i_Pr_In = 1; i_Pr_In <= 6; i_Pr_In++)                      // Print last entered values 
                    {
                    Adr_Arr[1]=(addr_Num&0xFF);                                         //extract first byte
                    Adr_Arr[0]=((addr_Num>>8)&0xFF);                                    //extract second byte
                    My_SPI_EEPROM_Read(Adr_Arr[0],Adr_Arr[1], What_getEEPROMdata,2);        
                    Freq_IN[i_Pr_In]=(What_getEEPROMdata[1]<<8)+What_getEEPROMdata[0];  // Load stored Values
                    addr_Num+=2;
                    Adr_Arr[1]=(addr_Num&0xFF);                                             //extract first byte
                    Adr_Arr[0]=((addr_Num>>8)&0xFF);                                        //extract second byte
                    My_SPI_EEPROM_Read(Adr_Arr[0],Adr_Arr[1], What_getEEPROMdata,1);        
                    dBmPower[i_Pr_In]=What_getEEPROMdata[0];                 
                    addr_Num+=1;
                    }
                break;                     
                }
            }
            key_int=0;
            show_scrn=0;        // To show Screen it HAS to be cleared in every Page
            break;
            }         
// F1    LOAD     
       if (key_int == 59)                   
           {
           // Enter Desired Project Number
            print("Enter Desired Project", 22, 149, 0); //  
            x_pos_Pr=374;
            y_pos_Pr=149;  
            i_count_Pr=0;
            while(true)                                                                     // Wait for ANY key
                {
                delay_ms(100);                              // Keyboard Delay 
                draw_battery();
                if (i_count_Pr >= 3)
                    {
                    h_check_flag_Pr=1;
                    }
                else
                    {
                    h_check_flag_Pr=0;  
                    }
                if ((key_int >= 0x30)&& (key_int <= 0x39)&& (h_check_flag_Pr==0))              //  
                    {
                    printChar(key_int, x_pos_Pr,y_pos_Pr);
                    x_pos_Pr +=16; 
                    Pr_chars[i_count_Pr]=key_int;
                    i_count_Pr++; 
                    if (i_count_Pr >= 3)                               // If more than 3 characters entered
                        {
                        h_check_flag_Pr=1;
                        error_flag_Pr=1;
                        break;
                        }
                    delay_ms(100);        
                    }
                if ((key_int == 108))                                                       // BackSpace 
                    {
                    if (i_count_Pr >0)
                        {
                        x_pos_Pr -=16; 
                        printChar(0x20, x_pos_Pr,y_pos_Pr);
                        i_count_Pr--;
                        }  
                    }
                if ((key_int == 0x0A))
                    {      
                    break;  
                    }   
                }

           // END entering
            if (i_count_Pr==2)
                {
                Curr_ProjNum= 10*(Pr_chars[0] & 0x0F);
                Curr_ProjNum += (Pr_chars[1] & 0x0F);
                }
            if (i_count_Pr==1)
                {            
                Curr_ProjNum = (Pr_chars[0] & 0x0F);
                } 
            if (Curr_ProjNum<= Lat_ProjNum)
                {
                True_ProjNum=Get_True(Curr_ProjNum);                            // Get True Project Number!
                addr_Num=True_ProjNum * 10 + (True_ProjNum+1)*10;               // Calculate the DeSIRED Project Number
                Adr_Arr[1]=(addr_Num&0xFF);                                     //extract first byte
                Adr_Arr[0]=((addr_Num>>8)&0xFF);                                //extract second byte
                My_SPI_EEPROM_Read(Adr_Arr[0],Adr_Arr[1], What_getEEPROMdata,20);
                addr_Num +=1;                
                for (i_Pr_In = 1; i_Pr_In <= 6; i_Pr_In++)                      // Print last entered values 
                    {
                    Adr_Arr[1]=(addr_Num&0xFF);                                 //extract first byte
                    Adr_Arr[0]=((addr_Num>>8)&0xFF);                            //extract second byte
                    My_SPI_EEPROM_Read(Adr_Arr[0],Adr_Arr[1], What_getEEPROMdata,2);    // Read from EEPROM 2 bytes            
                    Freq_IN[i_Pr_In]=(What_getEEPROMdata[1]<<8)+What_getEEPROMdata[0];  // Load stored Values
                    addr_Num+=2;
                    Adr_Arr[1]=(addr_Num&0xFF);                                             //extract first byte
                    Adr_Arr[0]=((addr_Num>>8)&0xFF);                                        //extract second byte
                    My_SPI_EEPROM_Read(Adr_Arr[0],Adr_Arr[1], What_getEEPROMdata,1);    // Read from EEPROM 1 byte        
                    dBmPower[i_Pr_In]=What_getEEPROMdata[0];                 
                    addr_Num+=1;
                    } 
                print("Project Loaded            ", 22, 149, 0); //                 
                }
            else
                {
                print("ERROR Load AGAIN        ", 22, 149, 0); //    
                }
 
           }
        }       
}

void Settings_In(void)
{
uint8_t stay_in_settings;
unsigned char YearChar[2], MonthChar[2], DateChar[2],HourChar[2], MinChar[2];
//###########========================== CHANNELS  Start
    stay_in_settings=0; 
    show_scrn_set=0;
    char read_rtcc[]  = {rtcc_sram_read,RTCYEAR,0};       // Year
    read_rtcc_sram( read_rtcc, 3, readBuffer,3);
    YearChar[0]=readBuffer[2];
    YearChar[1]=readBuffer[2];
    YearChar[0]= (YearChar[0] >> 4) | 0x30;
    YearChar[1]= (YearChar[1]&0x0F) | 0x30;
    read_rtcc[0] = rtcc_sram_read;
    read_rtcc[1] = RTCMTH;                                  // Month.
    read_rtcc[2] = 0x00;  
    read_rtcc_sram( read_rtcc, 3, readBuffer,3);
    MonthChar[0]=readBuffer[2];
    MonthChar[0]= MonthChar[0] & (~LPYR);                   // mask the leap year bit
    MonthChar[1]=MonthChar[0];
    MonthChar[0]= (MonthChar[0] >> 4) | 0x30;
    MonthChar[1]= (MonthChar[1]&0x0F) | 0x30;       
    read_rtcc[0] = rtcc_sram_read;
    read_rtcc[1] = RTCCDATE;                                  // Date
    read_rtcc[2] = 0x00;  
    read_rtcc_sram( read_rtcc, 3, readBuffer,3);   
    DateChar[0]=readBuffer[2];
    DateChar[1]=readBuffer[2];
    DateChar[0]= (DateChar[0] >> 4) | 0x30;
    DateChar[1]= (DateChar[1]&0x0F) | 0x30;
    read_rtcc[0] = rtcc_sram_read;
    read_rtcc[1] = RTCHOUR;                                  // Hour
    read_rtcc[2] = 0x00;  
    read_rtcc_sram( read_rtcc, 3, readBuffer,3);   
    HourChar[0]=readBuffer[2];
    HourChar[1]=readBuffer[2];
    HourChar[0]= (HourChar[0] >> 4) | 0x30;
    HourChar[1]= (HourChar[1]&0x0F) | 0x30;    
    read_rtcc[0] = rtcc_sram_read;
    read_rtcc[1] = RTCMIN;                                  // Min
    read_rtcc[2] = 0x00;  
    read_rtcc_sram( read_rtcc, 3, readBuffer,3);   
    MinChar[0]=readBuffer[2];
    MinChar[1]=readBuffer[2];
    MinChar[0]= (MinChar[0] >> 4) | 0x30;
    MinChar[1]= (MinChar[1]&0x0F) | 0x30;    
    while(true)                                     // Enter Parameters
        {    
        draw_battery();
        if (show_scrn_set==0)
            { 
            fillScr_1(217,217,217);             //(VGA_PURPLE);
            setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
            setBackColor_1(217,217,217);  
//            draw_battery();                  // RESTORE IT IF SPI TO 25Q10 WORK
         //   draw_Plug_bat();                  // If plugged to USB 
            setFont(SmallFont);         // SmallFont_8x12  // <------ 
//            print("-",430, 10,0);
//            print("-",435, 10,0);
//            print("-",442, 10,0);
//            print("%",449, 10,0);
            setColor(VGA_RED);             // Set color to all Draw, Fill and Print(letters)
            fillRect(0,296,480,319);
            setColor(VGA_WHITE);            // Set color to all Draw, Fill and Print(letters)
            setBackColor(VGA_RED);  
            setFont(arial_8x16); //Arial_round_16x24);         // Back to Arial 16X24 // <------     
            print("                                           BACK (F4)", 2, 302, 0); // Hor,Vert,Rotate
            setColor(VGA_BLACK);            // Set color to all Draw, Fill and Print(letters)
           setBackColor_1(217,217,217);
            setFont(arial_8x16); //Arial_round_16x24);         // Back to Arial 16X24 // <------  
            print("Press corresponded number on keypad  ", 2, 278, 0);
            setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
            setBackColor_1(217,217,217);  
            setFont(Arial_round_16x24);  
            
            print("SETTINGS", 7, 25, 0); // Hor,Vert,Rotate Enter Channel to set (1~6)
            drawLine(0,49, 479,49); 
            print("1.Device Info 2.Modules Info", 5, 73, 0); // 
            setColor_1(174,174,174);            // 
            fillRect(0,120,480,146);             // 1st Dark Grey fill Rect   
            setColor(VGA_BLACK); 
            setBackColor_1(174,174,174);        // Dark Grey
            setFont(Arial_round_16x24);    
            print("3.Calibrate 4.Keypad 5.Current", 5, 121, 0); // 
            setColor(VGA_BLACK);               // Set colour to all Draw, Fill and Print(letters)
            setBackColor_1(217,217,217);  
            setFont(Arial_round_16x24); 
            print("6.Activation:  ", 7, 169, 0);
            print("Date:  ", 7, 217, 0);
            printChar(0x32, 120, 217);
            printChar(0x30, 136, 217);
            printChar(YearChar[0], 152, 217);
            printChar(YearChar[1], 168, 217);
            printChar(0x2D, 184, 217);
            printChar(MonthChar[0], 200, 217);
            printChar(MonthChar[1], 216, 217);
            printChar(0x2D, 232, 217);
            printChar(DateChar[0], 248, 217);
            printChar(DateChar[1], 264, 217);  
            print("Time:  ", 7, 243, 0);
            printChar(HourChar[0], 120, 243);
            printChar(HourChar[1], 136, 243);
            printChar(0x2D, 152, 243);
            printChar(MinChar[0], 168, 243);
            printChar(MinChar[1], 184, 243);      
            show_scrn_set=0;    
            show_scrn_set=1;
            }      
            delay_ms(100); 
            if (key_int == 0x31)
                {
                Set_Dev_inf();
                show_scrn_set=0;
                if (key_int == 27)
                    break;    
                }
            if (key_int == 0x32)
                {
                Mod_inf();
                show_scrn_set=0;
                if (key_int == 27)
                    break;    
                }
            if (key_int == 0x33)
                {
                Calibr();
                show_scrn_set=0;
                if (key_int == 27)
                    break;
                }     
            if (key_int == 0x34)
                {
                Keypad();
                show_scrn_set=0;
                if (key_int == 27)
                    break;                
                }
            if (key_int == 0x35)
                {
                Current_Show();
                show_scrn_set=0;
                if (key_int == 27)
                    break;                
                }
             if (key_int == 0x36)
                {
                activation_screen();
                show_scrn_set=0;
                if (key_int == 27)
                    break;                
                }
            
     // F4 HOME goto home            
            if ((key_int == 62)||(key_int==27))         // F4 or ESC
                {                
                    // Go to HOME
                key_int=0;
                show_scrn=0;        // To show Screen it HAS to be cleared in every Page
                break;
                }       
        }       // While (true) END
   
}
void Help_In(void)
{
    fillScr_1(217,217,217);             //(VGA_PURPLE);
    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
//    draw_battery();                   // RESTORE IT IF SPI TO 25Q10 WORK

    setFont(SmallFont);         // SmallFont_8x12  // <------ 
//    print("-",430, 10,0);                   // RESTORE IT IF SPI TO 25Q10 WORK
//    print("-",435, 10,0);
//    print("-",442, 10,0);
//    print("%",449, 10,0);
    setColor(VGA_RED);             // Set color to all Draw, Fill and Print(letters)
    fillRect(0,296,480,319);
    setColor(VGA_WHITE);            // Set color to all Draw, Fill and Print(letters)
    setBackColor(VGA_RED);  
    setFont(arial_8x16); //Arial_round_16x24);         // Back to Arial 16X24 // <------     
    print("                                             HOME (F4)", 2, 302, 0); // Hor,Vert,Rotate

    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
    setFont(Arial_round_16x24);   
    print("HELP", 7, 25, 0); // Hor,Vert,Rotate Enter Channel to set (1~6)
    drawLine(0,49, 479,49); 
    setFont(arial_8x16);    
    print("Please visit: www.atecwireless.com for user?s manual",5,60, 0); //  
    print("Quick tips:", 5,80, 0); // 
    print(" -Press keypad numbers to Select desired line/ option", 5,100, 0);
    print(" -ESC button goes back to the previous page if applicable", 5,120, 0);
    print(" -Some functions require to press ?enter? button to ", 5,140, 0);
    print("confirm action", 5,160, 0);
    print(" -Arrow buttons will select/ navigate to selectable ", 5,180, 0);
    print("option on the screen", 5,200, 0);
    print(" -Press POWER button for 3 seconds to turn it off", 5,220, 0);
    print(" -Press POWER button for 2 seconds to turn it on", 5,240, 0);
    print(" -You may use a genuine  USB C charging cable ", 5,260, 0); 
    print("along with an adapter (5VDC 3A).", 5,280, 0);
    while(true)                                     // Enter Parameters
        {
        delay_ms(100); 
        draw_battery();
 // F4 HOME goto home            
        if ((key_int == 62) || (key_int ==27))      // F4 or ESC
            {                
                // Go to HOME
            key_int=0;
            show_scrn=0;        // To show Screen it HAS to be cleared in every Page
            break;
            }       
        }   
}

void Set_Dev_inf(void)
{
    int i_set, x_pos_set;
    
    fillScr_1(217,217,217);             //(VGA_PURPLE);
    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
//    draw_battery();                   // RESTORE IT IF SPI TO 25Q10 WORK
 //   draw_Plug_bat();                  // If plugged to USB 

    setFont(SmallFont);         // SmallFont_8x12  // <------ 
//    print("-",430, 10,0);                   // RESTORE IT IF SPI TO 25Q10 WORK
//    print("-",435, 10,0);
//    print("-",442, 10,0);
//    print("%",449, 10,0);
    setColor(VGA_RED);             // Set color to all Draw, Fill and Print(letters)
    fillRect(0,296,480,319);
    setColor(VGA_WHITE);            // Set color to all Draw, Fill and Print(letters)
    setBackColor(VGA_RED);  
    setFont(arial_8x16); //Arial_round_16x24);         // Back to Arial 16X24 // <------     
    print("        HOME (ESC)                         BACK (F4)", 2, 302, 0); // Hor,Vert,Rotate

    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
    setFont(Arial_round_16x24);   
    print("SETTINGS-> DEVICE INFO", 7, 25, 0); // Hor,Vert,Rotate Enter Channel to set (1~6)
    drawLine(0,49, 479,49);
    // <==== EEPROM_Read 
    My_SPI_EEPROM_Read(0x00,0x03, What_getEEPROMdata,11); 
    print("Serial Number  A0324020822", 7, 73, 0); // 
   /* x_pos_set=272;
    for (i_set = 0; i_set <= 10; i_set++)               // Print last entered values 
        { 
        printChar(What_getEEPROMdata[i_set], x_pos_set, 73);
        x_pos_set +=16;
        }  */
    setColor_1(174,174,174);            // 
    fillRect(0,120,480,146);             // 1st Dark Grey fill Rect   
    setColor(VGA_BLACK); 
    setBackColor_1(174,174,174);        // Dark Grey
    setFont(Arial_round_16x24);    
    print("Model           TxFlex 1", 7, 121, 0); // 
    setBackColor_1(217,217,217);  
    setFont(Arial_round_16x24);  
    My_SPI_EEPROM_Read(0x00,0x0E, What_getEEPROMdata,2); 
    print("Firmware       v", 7, 169, 0); // Hor,Vert,Rotate Enter Channel to set (1~6)
    printChar(What_getEEPROMdata[0], 272, 169);
    printChar(0x2E, 288, 169);
    printChar(What_getEEPROMdata[1], 304, 169);    
    
    while(true)                                     // Enter Parameters
    {
    delay_ms(100);
    draw_battery();
// F4 BACK goto home            
    if (key_int == 62)                                                  
        {                
            // Go to BACK
        key_int=0;
        show_scrn_set=0;        
        return;
        } 
      if (key_int == 27)                                                  
        {                
            // Go to HOME
        key_int=27;
        show_scrn=0;        // To show Screen it HAS to be cleared in every Page
        break;
        } 
    }  
    
}
void Mod_inf(void)
{
    fillScr_1(217,217,217);             //(VGA_PURPLE);
    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
//    draw_battery();                   // RESTORE IT IF SPI TO 25Q10 WORK
 //   draw_Plug_bat();                  // If plugged to USB 

    setFont(SmallFont);         // SmallFont_8x12  // <------ 
//    print("-",430, 10,0);                   // RESTORE IT IF SPI TO 25Q10 WORK
//    print("-",435, 10,0);
//    print("-",442, 10,0);
//    print("%",449, 10,0);
    setColor(VGA_RED);             // Set color to all Draw, Fill and Print(letters)
    fillRect(0,296,480,319);
    setColor(VGA_WHITE);            // Set color to all Draw, Fill and Print(letters)
    setBackColor(VGA_RED);  
    setFont(arial_8x16); //Arial_round_16x24);         // Back to Arial 16X24 // <------     
    print("        HOME (ESC)                         BACK (F4)", 2, 302, 0); // Hor,Vert,Rotate
    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
    setFont(Arial_round_16x24);   
    print("SETTINGS-> MODULES INFO", 7, 25, 0); // Hor,Vert,Rotate Enter Channel to set (1~6)
    drawLine(0,49, 479,49); 
    setFont(arial_8x16);
    print("Module       Status          End Freq   Max-Power   Mode", 7, 73, 0); // 
    drawLine(0,90, 479,90); 
    setBackColor_1(217,217,217); 
    print("Module 1    Installed        6000MHz     20dBm       CW", 7, 95, 0); //   
    setColor_1(174,174,174);            // 
//    fillRect(0,116,480,144);             // 1st Dark Grey fill Rect   
//    fillRect(0,168,480,196);            // 2ND Dark Grey fill Rect  
//    fillRect(0,220,480,248);            // 3rd Dark Grey fill Rect 
    setColor(VGA_BLACK); 
    setBackColor_1(174,174,174);        // Dark Grey    
    print("Module 2    Installed        6000MHz     20dBm       CW", 7, 121, 0); // 
    setBackColor_1(217,217,217);        // Ligth Grey???   
    print("Module 3    Installed        6000MHz     20dBm       CW", 7, 147, 0); // 
    setBackColor_1(174,174,174);        // Dark Grey 
    print("Module 4    Installed        6000MHz     20dBm       CW", 7, 173, 0); //
    setBackColor_1(217,217,217);       
    print("Module 5           NOT   Installed                   CW", 7, 199, 0); //
    setBackColor_1(174,174,174);        // Dark Grey         
    print("Module 6           NOT   Installed                   CW", 7, 225, 0); //    

    while(true)                                     // Enter Parameters
        {
        delay_ms(100);
        draw_battery();
    // F4 BACK goto home            
        if (key_int == 62)                                                  
            {                
                // Go to BACK
            key_int=0;
            show_scrn_set=0;        
            return;
            } 
          if (key_int == 27)                                                  
            {                
                // Go to HOME
            key_int=27;
            show_scrn=0;        // To show Screen it HAS to be cleared in every Page
            break;
            } 
        }    
        
}
void Calibr(void)
{
    fillScr_1(217,217,217);             //(VGA_PURPLE);
    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
//    draw_battery();                   // RESTORE IT IF SPI TO 25Q10 WORK
 //   draw_Plug_bat();                  // If plugged to USB 

    setFont(SmallFont);         // SmallFont_8x12  // <------ 
//    print("-",430, 10,0);                   // RESTORE IT IF SPI TO 25Q10 WORK
//    print("-",435, 10,0);
//    print("-",442, 10,0);
//    print("%",449, 10,0);
    setColor(VGA_RED);             // Set color to all Draw, Fill and Print(letters)
    fillRect(0,296,480,319);
    setColor(VGA_WHITE);            // Set color to all Draw, Fill and Print(letters)
    setBackColor(VGA_RED);  
    setFont(arial_8x16); //Arial_round_16x24);         // Back to Arial 16X24 // <------     
    print("        HOME (ESC)                         BACK (F4)", 2, 302, 0); // Hor,Vert,Rotate

    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
    setFont(Arial_round_16x24);   
    print("SETTINGS-> CALIBRATION INFO", 7, 25, 0); // Hor,Vert,Rotate Enter Channel to set (1~6)
    drawLine(0,49, 479,49); 
    print("Calibration History    Date", 7, 73, 0); // 
    setColor_1(174,174,174);            // 
    fillRect(0,120,480,146);             // 1st Dark Grey fill Rect   
    setColor(VGA_BLACK); 
    setBackColor_1(174,174,174);        // Dark Grey
    setFont(Arial_round_16x24);    
    print("1st                 Oct 2022", 7, 121, 0); //      
    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
    setFont(Arial_round_16x24);   
    print("Next Calibration    Oct 2023", 7, 145, 0); // Hor,Vert,Rotate Enter Channel to set (1~6) 
    while(true)                                     // Enter Parameters
        {
        delay_ms(100);
        draw_battery();
    // F4 BACK goto home            
        if (key_int == 62)                                                  
            {                
                // Go to BACK
            key_int=0;
            show_scrn_set=0;        
            return;
            } 
          if (key_int == 27)                                                  
            {                
                // Go to HOME
            key_int=27;
            show_scrn=0;        // To show Screen it HAS to be cleared in every Page
            break;
            } 
        }    
}
void Keypad(void)
{
    fillScr_1(217,217,217);             //(VGA_PURPLE);
    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
//    draw_battery();                   // RESTORE IT IF SPI TO 25Q10 WORK
 //   draw_Plug_bat();                  // If plugged to USB 

    setFont(SmallFont);         // SmallFont_8x12  // <------ 
//    print("-",430, 10,0);                   // RESTORE IT IF SPI TO 25Q10 WORK
//    print("-",435, 10,0);
//    print("-",442, 10,0);
//    print("%",449, 10,0);
    setColor(VGA_RED);             // Set color to all Draw, Fill and Print(letters)
    fillRect(0,296,480,319);
    setColor(VGA_WHITE);            // Set color to all Draw, Fill and Print(letters)
    setBackColor(VGA_RED);  
    setFont(arial_8x16); //Arial_round_16x24);         // Back to Arial 16X24 // <------     
    print("        HOME (ESC)                         BACK (F4)", 2, 302, 0); // Hor,Vert,Rotate

    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
    setFont(Arial_round_16x24);   
    print("SETTINGS-> KEYPAD", 7, 25, 0); // Hor,Vert,Rotate Enter Channel to set (1~6)
    drawLine(0,49, 479,49); 
    print("BEEPER                ON", 7, 95, 0); // 
    setColor_1(174,174,174);            // 
    fillRect(0,120,480,146);             // 1st Dark Grey fill Rect   
    setColor(VGA_BLACK); 
    setBackColor_1(174,174,174);        // Dark Grey
    setFont(Arial_round_16x24);    
    print("SENSITIVITY           HIGH", 7, 121, 0); //      
    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
    setFont(Arial_round_16x24);   
    print("POWER OFF             5 SEC", 7, 145, 0); // Hor,Vert,Rotate Enter Channel to set (1~6)
    while(true)                                     // Enter Parameters
        {
        delay_ms(100);
        draw_battery();
    // F4 BACK goto home            
        if (key_int == 62)                                                  
            {                
                // Go to BACK
            key_int=0;
            show_scrn_set=0;        
            return;
            } 
          if (key_int == 27)                                                  
            {                
                // Go to HOME
            key_int=27;
            show_scrn=0;        // To show Screen it HAS to be cleared in every Page
            break;
            } 
        }  
    return;
}


void Current_Show(void)
{
    fillScr_1(217,217,217);             //(VGA_PURPLE);
    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
//    draw_battery();                   // RESTORE IT IF SPI TO 25Q10 WORK
 //   draw_Plug_bat();                  // If plugged to USB 

    setFont(SmallFont);         // SmallFont_8x12  // <------ 
//    print("-",430, 10,0);                   // RESTORE IT IF SPI TO 25Q10 WORK
//    print("-",435, 10,0);
//    print("-",442, 10,0);
//    print("%",449, 10,0);
    setColor(VGA_RED);             // Set color to all Draw, Fill and Print(letters)
    fillRect(0,296,480,319);
    setColor(VGA_WHITE);            // Set color to all Draw, Fill and Print(letters)
    setBackColor(VGA_RED);  
    setFont(arial_8x16); //Arial_round_16x24);         // Back to Arial 16X24 // <------     
    print("        HOME (ESC)                         BACK (F4)", 2, 302, 0); // Hor,Vert,Rotate
    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
    setFont(Arial_round_16x24); 
    print("Current:", 7, 121, 0); // 
    DRV_ADC_Open();
    while(true)                                     // Enter Parameters
        {
        delay_ms(100);
        draw_battery();
        DRV_ADC_Start();
        delay_ms(1);
        while (!AD1CON1bits.DONE) 
            {
            ; // wait for the conversion process to finish
            }
        Adc_in=ADC1BUF0; // read the buffer with the result  
        DRV_ADC_Stop();
        Volt_Show=(float)ADC1BUF0*3.312/1023.0*2.2624-2.979;
        Volt_Show=Volt_Show*1000;
        // printNumF(double num, byte dec, int x, int y, char divider, int length, char filler);
        //printNumF(Volt_Show,3, 350, 260,'.',4, ' ');
        printNumI(Volt_Show, 135, 121, 1, ' ');
        print("mA", 207, 121, 0); 
        delay_ms(500);
    // F4 BACK goto home            
        if (key_int == 62)                                                  
            {                
                // Go to BACK
            DRV_ADC_Close();
            key_int=0;
            show_scrn_set=0;        
            return;
            } 
          if (key_int == 27)                                                  
            {                
                // Go to HOME
            DRV_ADC_Close();
            key_int=27;
            show_scrn=0;        // To show Screen it HAS to be cleared in every Page
            break;
            } 
        }  
    return;    
}

void Set_ON_OFF(void)
{

    YB_X1_s=327;                        // Draw the first Yellow Box
    YB_Y1_s=94;
    YB_X2_s=424;
    YB_Y2_s=119;
    YB_posY_s=1;   
    fillScr_1(217,217,217);             //Fill screen with Light Grey
    setColor(VGA_BLACK);     
    setFont(Arial_round_16x24); 
    setBackColor_1(217,217,217);        // Light Grey  
    print("RF-> SWITCH PORTS ", 7, 25, 0); // Hor,Vert,Rotate Enter Channel to set (1~6)
    drawLine(0,49, 479,49);  
    setFont(arial_8x16); //
    print("                                            STATUS", 10, 53, 0);
    setColor_1(174,174,174);            // 
    fillRect(0,93,480,120);             // 1st Dark Grey fill Rect
    setColor(VGA_BLACK); 
    drawLine(0,93, 479,93);  
    setBackColor_1(174,174,174);        // Dark Grey
    setFont(Arial_round_16x24);
    print("CH1                       ", 7, 97, 0);
    //print("2800.2   20     CW",103,97,0);
    setBackColor_1(217,217,217);        // Light Grey   
    print("CH2                       ", 7, 124, 0);
    setColor_1(174,174,174);  
    fillRect(0,148,480,174);            // 2nd Dark Grey fill Rect
    setBackColor_1(174,174,174);        // Dark Grey
    setColor(VGA_BLACK); 
    print("CH3                       ", 7, 151, 0);        
    setBackColor_1(217,217,217);        // Light Grey   
    print("CH4                       ", 7, 178, 0);
    setColor_1(174,174,174);  
    fillRect(0,202,480,228);            // 3rd Dark Grey fill Rect
    setBackColor_1(174,174,174);        // Dark Grey  
    setColor(VGA_BLACK); 
    print("CH5          NOT Installed ", 7, 205, 0);          
    setBackColor_1(217,217,217);        // Light Grey   
    print("CH6          NOT Installed ", 7, 232, 0);  
    y_pos_SON=97;
    for (i_SON = 1; i_SON < 5; i_SON++)
        {
        if ((i_SON==1)||(i_SON==3)||(i_SON==5))
            setBackColor_1(174,174,174);        // Dark Grey 
        else
            setBackColor_1(217,217,217);        // Light Grey    
        if (ONOFF_Chan[i_SON]== 1) 
            {
            print("ON", 360, y_pos_SON, 0);      
            }
        if (ONOFF_Chan[i_SON]== 0) 
            {
            print("OFF", 360, y_pos_SON, 0);      
            }
                       
        y_pos_SON +=27;
        }
    drawLine(0,259, 479,259);           // Last Bottom Line   
    setColor(VGA_RED);             // Set color to all Draw, Fill and Print(letters)
    fillRect(0,296,480,319);
    setColor(VGA_WHITE);            // Set color to all Draw, Fill and Print(letters)
    setBackColor(VGA_RED);  
    setFont(arial_8x16); //Arial_round_16x24);         // Back to Arial 16X24 // <------     
    print("ALL ON (F1)    ALL OFF (F2)                  BACK (F4)", 2, 302, 0); // Hor,Vert,Rotate
    setColor(VGA_YELLOW); 
    setColor_1(130,255,255); 
    drawRoundRect(YB_X1_s,YB_Y1_s,YB_X2_s,YB_Y2_s);          //YELLOW_BOX 1
 
     while(true)                                     // Enter Parameters
        {
        delay_ms(100); 
        draw_battery();
    // F4 BACK goto home 
        if (key_int == 59)                // F1    ALL ON                                              
            {  
            setColor(VGA_BLACK);     
            setFont(Arial_round_16x24); 
            for (i_SON = 1; i_SON < 5; i_SON++)
                {
                ONOFF_Chan[i_SON]=1;
                }
            y_pos_SON=97;
            for (i_SON = 1; i_SON < 5; i_SON++)
                {
                if ((i_SON==1)||(i_SON==3)||(i_SON==5))
                    setBackColor_1(174,174,174);        // Dark Grey 
                else
                    setBackColor_1(217,217,217);        // Light Grey    
                print("ON ", 360, y_pos_SON, 0);      
                y_pos_SON +=27;
                }
            }
        if (key_int == 60)                 // F2    ALL OFF                                          
            {
            setColor(VGA_BLACK);     
            setFont(Arial_round_16x24);
            for (i_SON = 1; i_SON < 5; i_SON++)
                {
                ONOFF_Chan[i_SON]=0;
                }
            y_pos_SON=97;
            for (i_SON = 1; i_SON < 5; i_SON++)
                {
                if ((i_SON==1)||(i_SON==3)||(i_SON==5))
                    setBackColor_1(174,174,174);        // Dark Grey 
                else
                    setBackColor_1(217,217,217);        // Light Grey    
                print("OFF", 360, y_pos_SON, 0);      
                y_pos_SON +=27;
                }
            }         
          if (key_int == 62)                                                  
            {                
                // Go to  BACK
            key_int=62;
            show_scrn=0;        // To show Screen it HAS to be cleared in every Page
            break;
            } 
        if (key_int == 27)                                                  
            {                
                // Go to HOME
            key_int=27;
            show_scrn_set=0;        
            break;
            } 
//UP & Down <============
            if (((key_int == 117)&&  (YB_posY_s == 1)) || ((key_int == 100)&& (YB_posY_s == 6)))       // UP or DOWN stay in position
                {
                setColor(VGA_YELLOW); 
                drawRoundRect(YB_X1_s,YB_Y1_s,YB_X2_s,YB_Y2_s);  
                }
 // UP
            if ((key_int == 117) && ((YB_posY_s == 2) || (YB_posY_s ==3)|| (YB_posY_s ==4)|| (YB_posY_s ==5)|| (YB_posY_s ==6)))             // Up
                {
                if (YB_posY_s ==1 || YB_posY_s ==3 || YB_posY_s ==5)                  // Erase YB 
                    {
                    setColor_1(174,174,174);                                    // Dark Grey
                    drawRoundRect(YB_X1_s,YB_Y1_s,YB_X2_s,YB_Y2_s);
                    }
                if (YB_posY_s ==2 || YB_posY_s ==4 || YB_posY_s ==6)                  // Erase YB 
                    {
                    setColor_1(217,217,217);                                    // Light Grey
                    drawRoundRect(YB_X1_s,YB_Y1_s,YB_X2_s,YB_Y2_s);
                    }                
                YB_Y1_s -=27;                                                    // DE-crease YB coordinates
                YB_Y2_s -=27;
                setColor(VGA_YELLOW);                                           // Draw new YB
                drawRoundRect(YB_X1_s,YB_Y1_s,YB_X2_s,YB_Y2_s); 
                YB_posY_s -=1;
                }           

// DOWN
            if ((key_int == 100) && ((YB_posY_s == 1) ||(YB_posY_s == 2) || (YB_posY_s ==3)))           // DOWN
                {
                if (YB_posY_s ==1 || YB_posY_s ==3 || YB_posY_s ==5)                  // Erase YB 
                    {
                    setColor_1(174,174,174);                                    // Dark Grey
                    drawRoundRect(YB_X1_s,YB_Y1_s,YB_X2_s,YB_Y2_s);
                    }
                if (YB_posY_s ==2 || YB_posY_s ==4 || YB_posY_s ==6)                  // Erase YB 
                    {
                    setColor_1(217,217,217);                                    // Light Grey
                    drawRoundRect(YB_X1_s,YB_Y1_s,YB_X2_s,YB_Y2_s);
                    }                
                YB_Y1_s +=27;                                                    // DE-crease YB coordinates
                YB_Y2_s +=27;
                setColor(VGA_YELLOW);                                           // Draw new YB
                drawRoundRect(YB_X1_s,YB_Y1_s,YB_X2_s,YB_Y2_s); 
                YB_posY_s +=1;
                }   
            
            if (key_int == 10)                                                  // ENTER to enter values
                {
                setColor(VGA_BLACK);     
                setFont(Arial_round_16x24); 
                setBackColor_1(217,217,217);          
                print("                                ", 10, 260, 0);          // Clear the Message Area       
                if (YB_posY_s ==1 || YB_posY_s ==3 || YB_posY_s ==5)                  //   
                    {
                    setBackColor_1(174,174,174);                                    // Dark Grey
                    }
                if (YB_posY_s ==2 || YB_posY_s ==4 || YB_posY_s ==6)                  //  
                    {
                    setBackColor_1(217,217,217);                                    // Light Grey
                    }  
                if (ONOFF_Chan[YB_posY_s]== 1)
                    {
                    ONOFF_Chan[YB_posY_s]=0;
                    print("OFF", 360, 97+(YB_posY_s-1)*27, 0); 
                    Trans_ONOFF_Chan[YB_posY_s]=0;                                // Transmit OFF
                    LED_CHAN_DE_Activate(YB_posY_s);
                    PDRF_PLL_DE_Activate(YB_posY_s);
//                    PDN_Ampl_DE_Activate(YB_posY_s);
                    }
                else
                    {
                    ONOFF_Chan[YB_posY_s]=1;
                    print("ON ", 360, 97+(YB_posY_s-1)*27, 0);
                    // LED_CHAN_Activate(YB_posY_s);// REMOVED because if there was no transmission and the LED was OFF 
//  CHECK IF OK!      PDRF_PLL_Activate(YB_posY_s);               // Leave enable if it was OFF nothing will transmitted 
//                    PDN_Ampl_Activate(YB_posY_s);               // if it was ON it will re-transmit 
                    }                 
                }  
//<============           
        } 
return;    
}

void test_RF_1()
{
        setColor(VGA_WHITE);            // Set colour to all Draw, Fill and Print(letters)
        setBackColor(VGA_RED);  
        setFont(arial_8x16); //Arial_round_16x24);         // Back to Arial 16X24 // <------          
        print("STOP (F1)     SAVE (F2)     SAVE_NEW(F3)     HOME (F4)", 2, 302, 0);            // Hor,Vert,Rotate 
        return;
}

void test_RF_2()
{
    setColor(VGA_WHITE);            // Set colour to all Draw, Fill and Print(letters)
    setBackColor(VGA_RED);  
    setFont(arial_8x16); //Arial_round_16x24);         // Back to Arial 16X24 // <------          
        print(" RUN (F1)     SAVE (F2)     SAVE_NEW(F3)     HOME (F4)", 2, 302, 0);            // Hor,Vert,Rotate 
    return;
}

void STOP_RF(void)
{
    int i_stp_RF;
    setColor(VGA_BLACK);
    setBackColor_1(217,217,217);  
    setFont(Arial_round_16x24);
    print("Stopping Channels      ", 10, 260, 0);                  //
    setColor(VGA_YELLOW);    
    for (i_stp_RF =1; i_stp_RF < 5; i_stp_RF++)  
    {
        Trans_ONOFF_Chan[i_stp_RF]=0;                                // Transmit OFF
        LED_CHAN_DE_Activate(i_stp_RF);
        PDRF_PLL_DE_Activate(i_stp_RF);
//        PDN_Ampl_DE_Activate(i_stp_RF);  
        if (i_stp_RF==1)
            fillCircle( 430,106,8);  	// Ch. 1
        if (i_stp_RF==2)
            fillCircle( 430,133,8);  	// Ch. 2
        if (i_stp_RF==3)                    
           fillCircle( 430,160,8);  	// Ch. 3
        if (i_stp_RF==4)                     
            fillCircle( 430,187,8);  	// Ch. 4  
            
    }    
    setColor(VGA_BLACK);
    setBackColor_1(217,217,217);  
    setFont(Arial_round_16x24);
    print("Channels are STOPPED        ", 10, 260, 0);                  // Message Error  
    delay_ms(1000); 
    print("                           ", 10, 260, 0);   
    return;    
}

void SPI_Voltages(uint8_t Bat_USB)
{
    dataOut[0] = Bat_USB;
    dataOut[1] = Bat_USB;
    dataOut[2]=  Bat_USB;
    dataOut[3]=  Bat_USB;
    dataOut[4] = Bat_USB;                                                       // POWER  
    dataOut[5] = Bat_USB;                                                       //
    dataOut[6] = Bat_USB;   
    dataOut[7] = Bat_USB;     
    dataIn[0]=0x00;
    dataIn[1]=0x00;
    dataIn[2]=0x00;
    dataIn[3]=0x00;
    dataIn[4]=0x00;
    dataIn[5]=0x00;
    dataIn[6]=0x00;
    dataIn[7]=0x00;    
    PLIB_SPI_ReceiverOverflowClear(SPI_ID_4); 
    PLIB_SPI_BufferClear (SPI_ID_4);

   
    LATFbits.LATF0=1;                                                           // Slave RTCC Select OFF                
    APP_SPI_CS_DESELECT();                                                      // EEPROM Select OFF
    LATFbits.LATF3=1;                                                           // Slave 67K40 Select OFF 
    LATFbits.LATF12=0;                                                          // Slave 25Q10 Select ON  
    
    delay_ms(1);      
    PLIB_SPI_BufferWrite (SPI_ID_4,dataOut[0]);
    dataIn[0]=PLIB_SPI_BufferRead(SPI_ID_4);
    PLIB_SPI_ReceiverOverflowClear(SPI_ID_4); 


    delay_ms(1); 
    PLIB_SPI_BufferWrite (SPI_ID_4,dataOut[1]);
    dataIn[1]=PLIB_SPI_BufferRead(SPI_ID_4);
 
    PLIB_SPI_ReceiverOverflowClear(SPI_ID_4);    
    
    delay_ms(1); 
    PLIB_SPI_BufferWrite (SPI_ID_4,dataOut[2]);
    dataIn[2]=PLIB_SPI_BufferRead(SPI_ID_4);

    PLIB_SPI_ReceiverOverflowClear(SPI_ID_4);
   
    delay_ms(1); 
    PLIB_SPI_BufferWrite (SPI_ID_4,dataOut[3]);
    dataIn[3]=PLIB_SPI_BufferRead(SPI_ID_4);

     PLIB_SPI_ReceiverOverflowClear(SPI_ID_4); 
 
    delay_ms(1); 
    PLIB_SPI_BufferWrite (SPI_ID_4,dataOut[4]);
    dataIn[4]=PLIB_SPI_BufferRead(SPI_ID_4);
 
    PLIB_SPI_ReceiverOverflowClear(SPI_ID_4); 

    delay_ms(1); 
    PLIB_SPI_BufferWrite (SPI_ID_4,dataOut[5]);
    dataIn[5]=PLIB_SPI_BufferRead(SPI_ID_4);
 
    PLIB_SPI_ReceiverOverflowClear(SPI_ID_4);

    delay_ms(1); 
    PLIB_SPI_BufferWrite (SPI_ID_4,dataOut[6]);
    PLIB_SPI_ReceiverOverflowClear(SPI_ID_4);
 
    dataIn[6]=PLIB_SPI_BufferRead(SPI_ID_4);  
    
    delay_ms(1);
    PLIB_SPI_BufferWrite (SPI_ID_4,dataOut[7]);
    PLIB_SPI_ReceiverOverflowClear(SPI_ID_4);
 
    dataIn[7]=PLIB_SPI_BufferRead(SPI_ID_4);
    delay_ms(1);


    PLIB_SPI_BufferClear (SPI_ID_4);
    PLIB_SPI_BufferClear (SPI_ID_4); 
    PLIB_SPI_ReceiverOverflowClear(SPI_ID_4);    
   
    LATFbits.LATF0=1;                                                           // Slave RTCC Select OFF                
    APP_SPI_CS_DESELECT();                                                      // EEPROM Select OFF
    LATFbits.LATF3=1;                                                           // Slave 67K40 Select OFF 
    LATFbits.LATF12=1;                                                         // Slave 25Q10 Select OFF 

   
    if ((dataIn[3]==0xee)&& (Bat_USB==1))   // Batteries
        {
        Bat1_ADC=0;
        Bat2_ADC=0;
        Bat1_ADC |= dataIn[4]& 0xffff;
        Bat1_ADC= Bat1_ADC << 8;
        Bat1_ADC |= dataIn[5]& 0xffff;
        Bat2_ADC |= dataIn[6]& 0xffff;
        Bat2_ADC= Bat2_ADC << 8;
        Bat2_ADC |= dataIn[7]& 0xffff;  
        Flag_SPI_Bat=true;
        }
   if ((dataIn[3]==0xaa)&& (Bat_USB==2))
        {
        USB_ADC=0; 
        USB_ADC |= dataIn[4]& 0xffff;
        USB_ADC= USB_ADC << 8;
        USB_ADC |= dataIn[5]& 0xffff; 
        Flag_SPI_USB=true; 
        }
 
}

void Lamda_Set(void)
{
    int i_Pr_In,i_count_Pr;
    int x_pos_Pr, y_pos_Pr;
    uint8_t h_check_flag_Pr,error_flag_Pr; 
    unsigned char Pr_chars[7], SN_chars[21],Ch_chars[3] ;
    char write_rtcc[3],help_deb[3];
    char A, B,C;
    h_check_flag_Pr=0;
    error_flag_Pr=0;
    i_count_Pr=0;
    fillScr_1(217,217,217);             //(VGA_PURPLE);
    setColor(VGA_BLACK);               // Set colour to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
//    draw_battery();                   // RESTORE IT IF SPI TO 25Q10 WORK
//    draw_Plug_bat();                  // If plugged to USB 
    setFont(SmallFont);         // SmallFont_8x12  // <------ 
//    print("-",430, 10,0);                   // RESTORE IT IF SPI TO 25Q10 WORK
//    print("-",435, 10,0);
//    print("-",442, 10,0);
//    print("%",449, 10,0);
    setColor(VGA_RED);                  // Set color to all Draw, Fill and Print(letters)
    fillRect(0,296,480,319);
    setColor(VGA_WHITE);                // Set color to all Draw, Fill and Print(letters)
    setBackColor(VGA_RED);  
    setFont(arial_8x16);                //Arial_round_16x24);         // Back to Arial 16X24 // <------     
    print("                                             HOME (F4)", 2, 302, 0); // Hor,Vert,Rotate

    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
    setFont(Arial_round_16x24);   
    print("Enter ", 7, 25, 0);          // Hor,Vert,Rotate Enter Channel to set (1~6)
    drawLine(0,49, 479,49); 
    print("---1", 22, 123, 0); //         
//    draw_battery();

    
    while(true)                                     // Enter Parameters
        {
        delay_ms(keyb_sens); 

// F4 HOME goto home            
        if ((key_int == 62) ||(key_int ==27))                                                  
            {                
                // Go to HOME
            key_int=0;
            show_scrn=0;        // To show Screen it HAS to be cleared in every Page
            break;
            }  
// F1    LOAD     
        if (key_int == 59)                   
            {
           // Enter Desired Project Number
            print("Enter PIN", 22, 149, 0); //  
            x_pos_Pr=350;
            y_pos_Pr=149;  
            i_count_Pr=0;
            while(true)                                                                     // Wait for ANY key
                {
                delay_ms(keyb_sens); 
//                draw_battery();
                if (i_count_Pr >= 8)
                    {
                    h_check_flag_Pr=1;
                    }
                else
                    {
                    h_check_flag_Pr=0;  
                    }
                if ((key_int >= 0x30)&& (key_int <= 0x39)&& (h_check_flag_Pr==0))              //  
                    {
                    printChar(key_int, x_pos_Pr,y_pos_Pr);
                    x_pos_Pr +=16; 
                    Pr_chars[i_count_Pr]=key_int;
                    i_count_Pr++; 
                    if (i_count_Pr >= 8)                               // If more than 3 characters entered
                        {
                        h_check_flag_Pr=1;
                        error_flag_Pr=1;
                        break;
                        }
                    delay_ms(100);        
                    }
                if ((key_int == 108))                                                       // BackSpace 
                    {
                    if (i_count_Pr >0)
                        {
                        x_pos_Pr -=16; 
                        printChar(0x20, x_pos_Pr,y_pos_Pr);
                        i_count_Pr--;
                        }  
                    }
                if ((key_int == 0x0A))
                    {      
                    break;  
                    }   
                }

// END entering
// 52632123            
            if ((Pr_chars[0]==0x35) && (Pr_chars[1]==0x32)&& (Pr_chars[2]==0x36)&& (Pr_chars[3]==0x33)&& (Pr_chars[4]==0x32)&& (Pr_chars[5]==0x31)&& (Pr_chars[6]==0x32)&& (Pr_chars[7]==0x33))
                {
                    print("Correct                       ", 22, 149, 0); //   
                    delay_ms(700);
                    //<===== Selection SN or RTCC
                    print("Enter Selection               ", 22, 149, 0);  
    //===============================================
                    x_pos_Pr=350;
                    y_pos_Pr=149;  
                    i_count_Pr=0;
                    while(true)                                                                     // Wait for ANY key
                        {
                        delay_ms(keyb_sens); 
        //                draw_battery();
                        if (i_count_Pr >= 2)
                            {
                            h_check_flag_Pr=1;
                            }
                        else
                            {
                            h_check_flag_Pr=0;  
                            }
                        if ((key_int >= 0x30)&& (key_int <= 0x39)&& (h_check_flag_Pr==0))              //  
                            {
                            printChar(key_int, x_pos_Pr,y_pos_Pr);
                            x_pos_Pr +=16; 
                            Ch_chars[i_count_Pr]=key_int;
                            i_count_Pr++; 
                            if (i_count_Pr >= 2)                               // If more than 3 characters entered
                                {
                                h_check_flag_Pr=1;
                                error_flag_Pr=1;
                                break;
                                }
                            delay_ms(100);        
                            }
                        if ((key_int == 108))                                                       // BackSpace 
                            {
                            if (i_count_Pr >0)
                                {
                                x_pos_Pr -=16; 
                                printChar(0x20, x_pos_Pr,y_pos_Pr);
                                i_count_Pr--;
                                }  
                            }
                        if ((key_int == 0x0A))
                            {      
                            break;  
                            }   
                        }                
    //-----------------------------------------------      
                    if (Ch_chars[0] == 0x031)
                    {                
                        print("Enter DATA 16 Digits          ", 22, 149, 0);
                        // Clear Screen 
                        x_pos_Pr=22;
                        y_pos_Pr=172;  
                        i_count_Pr=0;    
                        while(true)                                                                     // Wait for ANY key
                            {
                            delay_ms(keyb_sens); 
                            if (i_count_Pr >= 16)
                                {
                                h_check_flag_Pr=1;
                                }
                            else
                                {
                                h_check_flag_Pr=0;  
                                }
                            if ((key_int >= 0x30)&& (key_int <= 0x39)&& (h_check_flag_Pr==0))              //  
                                {
                                printChar(key_int, x_pos_Pr,y_pos_Pr);
                                x_pos_Pr +=16; 
                                SN_chars[i_count_Pr]=key_int;
                                i_count_Pr++; 
                                if (i_count_Pr >= 16)                               // If more than 12 characters entered
                                    {
                                    key_int=0;
                                    show_scrn=0;        // To show Screen it HAS to be cleared in every Page
                                    h_check_flag_Pr=1;
                                    error_flag_Pr=1;
                                    print("OK 16 Digits Entered          ", 22, 149, 0); //
                                    My_SPI_EEPROM_Write(0x00,0x00, SN_chars, 16); 
                                    delay_ms(700);
                                    break;
                                    }
                                delay_ms(keyb_sens);        
                                }
                            if ((key_int == 108))                                     // BackSpace 
                                {
                                if (i_count_Pr >0)
                                    {
                                    x_pos_Pr -=16; 
                                    printChar(0x20, x_pos_Pr,y_pos_Pr);
                                    i_count_Pr--;
                                    }  
                                }
                            if ((key_int == 0x0A))
                                {      
                                break;  
                                }   
                        }
                    }
                    if (Ch_chars[0] == 0x039)
                    {                 
                        print("Enter RTCC DATA 10 Digits     ", 22, 149, 0);
                        print("                              ", 22, 172, 0);
                        x_pos_Pr=22;
                        y_pos_Pr=172;  
                        i_count_Pr=0;    
                        while(true)                                                                     // Wait for ANY key
                            {
                            delay_ms(keyb_sens); 
                            if (i_count_Pr >= 10)
                                {
                                h_check_flag_Pr=1;
                                }
                            else
                                {
                                h_check_flag_Pr=0;  
                                }
                            if ((key_int >= 0x30)&& (key_int <= 0x39)&& (h_check_flag_Pr==0))              //  
                                {
                                printChar(key_int, x_pos_Pr,y_pos_Pr);
                                x_pos_Pr +=16; 
                                SN_chars[i_count_Pr]=key_int;
                                i_count_Pr++; 
                                if (i_count_Pr >= 10)                               // If more than 12 characters entered
                                    {
                                    key_int=0;
                                    show_scrn=0;        // To show Screen it HAS to be cleared in every Page
                                    h_check_flag_Pr=1;
                                    error_flag_Pr=1;
                                    print("OK 10 Digits Entered          ", 22, 149, 0); //
        //                            My_SPI_EEPROM_Write(0x00,0x00, SN_chars, 15); 
                                    // WRITE TO RTCC, YY-MM-DD-HH-MM
                                    write_rtcc[0] = SPI_RTCC_WRITE;
                                    write_rtcc[1] = RTCYEAR;
                                    help_deb[0]=SN_chars[0]<<4;
                                    help_deb[1]=SN_chars[1] & 0x0F;
                                    help_deb[2]=help_deb[0] | help_deb[1];
                                    write_rtcc[2]=help_deb[2];
                                    write_rtcc_sram( write_rtcc, 3);
                                    // WRITE TO RTCC, YY-MM-DD-HH-MM
                                    write_rtcc[0] = SPI_RTCC_WRITE;
                                    write_rtcc[1] = RTCMTH;
                                    help_deb[0]=SN_chars[2]<<4;
                                    help_deb[1]=SN_chars[3] & 0x0F;
                                    help_deb[2]=help_deb[0] | help_deb[1];
                                    write_rtcc[2]=help_deb[2];
                                    write_rtcc_sram( write_rtcc, 3); 
                                    // WRITE TO RTCC, YY-MM-DD-HH-MM
                                    write_rtcc[0] = SPI_RTCC_WRITE;
                                    write_rtcc[1] = RTCCDATE;
                                    help_deb[0]=SN_chars[4]<<4;
                                    help_deb[1]=SN_chars[5] & 0x0F;
                                    help_deb[2]=help_deb[0] | help_deb[1];
                                    write_rtcc[2]=help_deb[2];
                                    write_rtcc_sram( write_rtcc, 3);                             
                                    // WRITE TO RTCC, YY-MM-DD-HH-MM
                                    write_rtcc[0] = SPI_RTCC_WRITE;
                                    write_rtcc[1] = RTCHOUR;
                                    help_deb[0]=SN_chars[6]<<4;
                                    help_deb[1]=SN_chars[7] & 0x0F;
                                    help_deb[2]=help_deb[0] | help_deb[1];
                                    write_rtcc[2]=help_deb[2];
                                    write_rtcc_sram( write_rtcc, 3);                            
                                    // WRITE TO RTCC, YY-MM-DD-HH-MM
                                    write_rtcc[0] = SPI_RTCC_WRITE;
                                    write_rtcc[1] = RTCMIN;
                                    help_deb[0]=SN_chars[8]<<4;
                                    help_deb[1]=SN_chars[9] & 0x0F;
                                    help_deb[2]=help_deb[0] | help_deb[1];
                                    write_rtcc[2]=help_deb[2];
                                    write_rtcc_sram( write_rtcc, 3);                            

                                    delay_ms(1000);
                                    break;
                                    }
                                delay_ms(keyb_sens);        
                                }
                            if ((key_int == 108))                                                       // BackSpace 
                                {
                                if (i_count_Pr >0)
                                    {
                                    x_pos_Pr -=16; 
                                    printChar(0x20, x_pos_Pr,y_pos_Pr);
                                    i_count_Pr--;
                                    }  
                                }
                            if ((key_int == 0x0A))
                                {      
                                break;  
                                }   
                        }

                    }
                    // Write Beep, Channels, SN
                    // Write 1st Default Project
                }
            else
                {
                print("ERROR Enter AGAIN              ", 22, 149, 0); // 
                delay_ms(800);
                show_scrn=0;
                break;
                }
           }
        }    
}

unsigned char Get_True(unsigned char Enter_ProjNum)
{
unsigned char Real_ProjNum;

switch (Enter_ProjNum) {
    case 1: 
        Real_ProjNum=1;
        break;
    case 2: 
        Real_ProjNum=3;
        break;
    case 3: 
        Real_ProjNum=4;
        break;
    case 4: 
        Real_ProjNum=6;
        break;
    case 5: 
        Real_ProjNum=7;
        break;
    case 6: 
        Real_ProjNum=8;
        break;
    case 7: 
        Real_ProjNum=10;
        break;
    case 8: 
        Real_ProjNum=11;
        break; 
    case 9: 
        Real_ProjNum=13;
        break;
    case 10: 
        Real_ProjNum=14;
        break; 
//====== 1X        
    case 11: 
        Real_ProjNum=16;
        break;
    case 12: 
        Real_ProjNum=17;
        break;
    case 13: 
        Real_ProjNum=19;
        break;
    case 14: 
        Real_ProjNum=20;
        break;
    case 15: 
        Real_ProjNum=22;
        break;
    case 16: 
        Real_ProjNum=23;
        break;
    case 17: 
        Real_ProjNum=24;
        break;
    case 18: 
        Real_ProjNum=26;
        break; 
    case 19: 
        Real_ProjNum=27;
        break;
    case 20: 
        Real_ProjNum=29;
        break; 
//==== 2X
    case 21: 
        Real_ProjNum=30;
        break;
    case 22: 
        Real_ProjNum=32;
        break;
    case 23: 
        Real_ProjNum=33;
        break;
    case 24: 
        Real_ProjNum=35;
        break;
    case 25: 
        Real_ProjNum=36;
        break;
    case 26: 
        Real_ProjNum=38;
        break;
    case 27: 
        Real_ProjNum=39;
        break;
    case 28: 
        Real_ProjNum=40;
        break; 
    case 29: 
        Real_ProjNum=42;
        break;
    case 30: 
        Real_ProjNum=43;
        break; 
//===== 3X
    case 31: 
        Real_ProjNum=45;
        break;
    case 32: 
        Real_ProjNum=46;
        break;
    case 33: 
        Real_ProjNum=48;
        break;
    case 34: 
        Real_ProjNum=49;
        break;
    case 35: 
        Real_ProjNum=51;
        break;
    case 36: 
        Real_ProjNum=52;
        break;
    case 37: 
        Real_ProjNum=54;
        break;
    case 38: 
        Real_ProjNum=55;
        break; 
    case 39: 
        Real_ProjNum=56;
        break;
    case 40: 
        Real_ProjNum=58;
        break; 
//=== 4X
    case 41: 
        Real_ProjNum=59;
        break;
    case 42: 
        Real_ProjNum=61;
        break;
    case 43: 
        Real_ProjNum=62;
        break;
    case 44: 
        Real_ProjNum=64;
        break;
    case 45: 
        Real_ProjNum=65;
        break;
    case 46: 
        Real_ProjNum=67;
        break;
    case 47: 
        Real_ProjNum=68;
        break;
    case 48: 
        Real_ProjNum=70;
        break; 
    case 49: 
        Real_ProjNum=71;
        break;
    case 50: 
        Real_ProjNum=72;
        break; 
//==== 5X
    case 51: 
        Real_ProjNum=74;
        break;
    case 52: 
        Real_ProjNum=75;
        break;
    case 53: 
        Real_ProjNum=77;
        break;
    case 54: 
        Real_ProjNum=78;
        break;
    case 55: 
        Real_ProjNum=80;
        break;
    case 56: 
        Real_ProjNum=81;
        break;
    case 57: 
        Real_ProjNum=83;
        break;
    case 58: 
        Real_ProjNum=84;
        break; 
    case 59: 
        Real_ProjNum=86;
        break;
    case 60: 
        Real_ProjNum=87;
        break; 
//===== 6X
    case 61: 
        Real_ProjNum=88;
        break;
    case 62: 
        Real_ProjNum=90;
        break;
    case 63: 
        Real_ProjNum=91;
        break;
    case 64: 
        Real_ProjNum=93;
        break;
    case 65: 
        Real_ProjNum=94;
        break;
    case 66: 
        Real_ProjNum=96;
        break;
    case 67: 
        Real_ProjNum=97;
        break;
    case 68: 
        Real_ProjNum=99;
        break; 
    case 69: 
        Real_ProjNum=100;
        break;
    case 70: 
        Real_ProjNum=102;
        break; 
//==== 7X
    case 71: 
        Real_ProjNum=103;
        break;
    case 72: 
        Real_ProjNum=104;
        break;
    case 73: 
        Real_ProjNum=106;
        break;
    case 74: 
        Real_ProjNum=107;
        break;
    case 75: 
        Real_ProjNum=109;
        break;
    case 76: 
        Real_ProjNum=110;
        break;
    case 77: 
        Real_ProjNum=112;
        break;
    case 78: 
        Real_ProjNum=113;
        break; 
    case 79: 
        Real_ProjNum=115;
        break;
    case 80: 
        Real_ProjNum=116;
        break; 
//=== 8X
    case 81: 
        Real_ProjNum=118;
        break;
    case 82: 
        Real_ProjNum=119;
        break;
    case 83: 
        Real_ProjNum=120;
        break;
    case 84: 
        Real_ProjNum=122;
        break;
    case 85: 
        Real_ProjNum=123;
        break;
    case 86: 
        Real_ProjNum=125;
        break;
    case 87: 
        Real_ProjNum=126;
        break;
    case 88: 
        Real_ProjNum=128;
        break; 
    case 89: 
        Real_ProjNum=129;
        break;
    case 90: 
        Real_ProjNum=131;
        break; 
//==== 9X
    case 91: 
        Real_ProjNum=132;
        break;
    case 92: 
        Real_ProjNum=134;
        break;
    case 93: 
        Real_ProjNum=135;
        break;
    case 94: 
        Real_ProjNum=136;
        break;
    case 95: 
        Real_ProjNum=138;
        break;
    case 96: 
        Real_ProjNum=139;
        break;
    case 97: 
        Real_ProjNum=141;
        break;
    case 98: 
        Real_ProjNum=142;
        break; 
    case 99: 
        Real_ProjNum=144;
        break;
    case 100: 
        Real_ProjNum=145;
        break; 
      
    default:
        Real_ProjNum=1;
        break;            
}
return(Real_ProjNum)   ;
}

int Min_Max_Power(int dBm_in, int x_pos_dB_M, int y_pos_dB_M, int Min_in, int Max_in )
{
if (dBm_in <Min_in)
    {
    dBm_in=Min_in;
    print("    ",x_pos_dB_M, y_pos_dB_M,0);
    printNumI(dBm_in, x_pos_dB_M, y_pos_dB_M, 2,' ');
    print("Lowest applicable dBm        ", 10, 260, 0);
    delay_ms(1000); 
    return dBm_in;
    }
if (dBm_in > Max_in)
    {
    dBm_in=Max_in;
    print("    ",x_pos_dB_M, y_pos_dB_M,0);
    printNumI(dBm_in, x_pos_dB_M, y_pos_dB_M, 2,' ');
    print("Highest applicable dBm        ", 10, 260, 0);
    delay_ms(1000); 
    return dBm_in;
    }
return dBm_in;
}


void Calib(void)
{
clrScr();
setColor(VGA_BLACK);     
setFont(Arial_round_16x24); 
setBackColor_1(217,217,217);  
print("Wait for USB input", 2, 302, 0); // Hor,Vert,Rotate
while (1)
    {
    if (!DRV_USART0_ReceiverBufferIsEmpty())
        {
           rx_byte = DRV_USART0_ReadByte(); // 1st byte
           switch (rx_byte)
           {
               case 0x41:
                   DRV_USART0_WriteByte(0x31); 
                   delay_ms(5);      
                   if (!DRV_USART0_ReceiverBufferIsEmpty())
                   {
                       rx_byte = DRV_USART0_ReadByte();     // 2nd byte
                       if (rx_byte == 0x42)
                       {
                           DRV_USART0_WriteByte(0x31);      // send OK                             
                       }
                       else
                       {
                           DRV_USART0_WriteByte(0x30);      // send ERROR                              
                           break;
                       }
                   }
                   if (!DRV_USART0_ReceiverBufferIsEmpty())
                   {
                       S_Data[0]=DRV_USART0_ReadByte(); // 3rd byte
                   }
                   if (!DRV_USART0_ReceiverBufferIsEmpty())
                   {
                       S_Data[1]=DRV_USART0_ReadByte(); // 4th byte
                   }                       
                   if (!DRV_USART0_ReceiverBufferIsEmpty())
                   {
                       S_Data[2]=DRV_USART0_ReadByte(); // 5th byte
                   }     
                   if (!DRV_USART0_ReceiverBufferIsEmpty())
                   {
                       rx_byte=DRV_USART0_ReadByte(); // 6th byte
                       if (rx_byte == 0x35)
                       {
                           DRV_USART0_WriteByte(0x31); // send OK  
                           Flag_Send_Freq=true; 
                       }
                       else
                       {
                           DRV_USART0_WriteByte(0x30);   // send ERROR                            
                           break;                               
                       }
                   }                       
                   break;
               default:
                   break;
           }

        }

        if (Flag_Send_Freq)
        {
            Freq_Send= S_Data[1];
            Freq_Send= Freq_Send<<8; 
            Freq_Send=Freq_Send+S_Data[0];
            // 
            //Send Frequency to ALL CHANNELS
            for (channel=1; channel < 7; channel++) 
            {
//            send_SPI_settings(channel,Freq_Send,S_Data[2] );         // Send to 67K40 settings (Power Hanging)  
//            delay_ms(5);                          // 2X TIMES WHY to be checked!!!!
//            send_SPI_settings(channel,Freq_Send,S_Data[2] );         // Send to 67K40 settings (Power Hanging)    
//            delay_ms(5);
                Freq_IN[channel]=Freq_Send;
                if (Freq_Send == 0)          // If Frequency is 0 STOP RF CHANNELS
                    STOP_RF();
                else
                {
                dBmPower[channel]=(int8_t) S_Data[2];   // 
//                Set_RF();                
//                printNumI(Freq_Send/10, 268, 25, 3, ' ');        
                }             
            }
            Set_RF();                
            printNumI(Freq_Send/10, 268, 25, 3, ' ');              
            for (channel=1; channel < 7; channel++)
            {
            LED_CHAN_DE_Activate(channel);                 
            }
//        delay_ms(500);            
        Flag_Send_Freq= false;  
        _DRV_USART0_ErrorConditionClear();
        }  
       if ((key_int == 62) || (key_int ==27))      // F4 or ESC
            {                
                // Go to HOME
            key_int=0;
            show_scrn=0;        // To show Screen it HAS to be cleared in every Page
            break;
            }  
    }      
}


void  Turn_OFF(void)
{
clrScr();
setColor(VGA_BLACK);     
setFont(Arial_round_16x24); 
setBackColor_1(217,217,217);  
print("Turn OFF press ENTER", 2, 302, 0); // Hor,Vert,Rotate  
while (1)
{
    delay_ms(100);  
    if ((key_int == 62) || (key_int ==27))      // F4 or ESC
        {                
            // Go to HOME
        key_int=0;
        show_scrn=0;        // To show Screen it HAS to be cleared in every Page
        break;
        }
    delay_ms(100);      
    if (key_int == 10)              // ENTER 
    {
        SPI_Voltages(3);            // Send TURN OFF command -3- 
        print("Turn OFF sent Wait   ", 2, 302, 0); // Hor,Vert,Rotate
    }
}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 

void activation_screen(void)
{
    int i_set, x_pos_set;
    
    fillScr_1(217,217,217);             //(VGA_PURPLE);
    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
//    draw_battery();                   // RESTORE IT IF SPI TO 25Q10 WORK
 //   draw_Plug_bat();                  // If plugged to USB 

    setFont(SmallFont);         // SmallFont_8x12  // <------ 
//    print("-",430, 10,0);                   // RESTORE IT IF SPI TO 25Q10 WORK
//    print("-",435, 10,0);
//    print("-",442, 10,0);
//    print("%",449, 10,0);
    setColor(VGA_RED);             // Set color to all Draw, Fill and Print(letters)
    fillRect(0,296,480,319);
    setColor(VGA_WHITE);            // Set color to all Draw, Fill and Print(letters)
    setBackColor(VGA_RED);  
    setFont(arial_8x16); //Arial_round_16x24);         // Back to Arial 16X24 // <------     
    print("   Activation (F1)                         BACK (F4)", 2, 302, 0); // Hor,Vert,Rotate

    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
    setFont(Arial_round_16x24);   
    print("Activation-> 4GHz to 6GHz", 7, 25, 0); // Hor,Vert,Rotate Enter Channel to set (1~6)
    drawLine(0,49, 479,49);
    // <==== EEPROM_Read 
    My_SPI_EEPROM_Read(0x00,0x03, What_getEEPROMdata,11); 
    print("please contact to support", 7, 73, 0); // 
   /* x_pos_set=272;
    for (i_set = 0; i_set <= 10; i_set++)               // Print last entered values 
        { 
        printChar(What_getEEPROMdata[i_set], x_pos_set, 73);
        x_pos_set +=16;
        }  */
    setColor_1(174,174,174);            // 
    fillRect(0,120,480,146);             // 1st Dark Grey fill Rect   
    setColor(VGA_BLACK); 
    setBackColor_1(174,174,174);        // Dark Grey
    setFont(Arial_round_16x24);    
    print("to upgrade the Frq.", 7, 121, 0); // 
    setBackColor_1(217,217,217);  
    setFont(Arial_round_16x24);  
    My_SPI_EEPROM_Read(0x00,0x0E, What_getEEPROMdata,2); 
   // print("Firmware       v", 7, 169, 0); // Hor,Vert,Rotate Enter Channel to set (1~6)
   // printChar(What_getEEPROMdata[0], 272, 169);
   // printChar(0x2E, 288, 169);
   // printChar(What_getEEPROMdata[1], 304, 169);  
    //activation_Set();
    
    while(true)                                     // Enter Parameters
    {
    delay_ms(100);
    draw_battery();
// F4 BACK goto home            
    if ((key_int == 62) ||(key_int ==27))                                                 
        {                
            // Go to BACK
        key_int=0;
        show_scrn_set=0;        
        return;
        } 
    if (key_int == 59)
                {
                activation_Set();
                show_scrn_set=0;
                if (key_int == 27)
                    break;                
                }
      if (key_int == 27)                                                  
        {                
            // Go to HOME
        key_int=27;
        show_scrn=0;        // To show Screen it HAS to be cleared in every Page
        break;
        } 
    }  
    
}

void activation_Set(void)
{
    int i_Pr_In,i_count_Pr;
    int x_pos_Pr, y_pos_Pr;
    uint8_t h_check_flag_Pr,error_flag_Pr; 
    unsigned char Pr_chars[7], SN_chars[21],Ch_chars[3] ;
    char write_rtcc[3],help_deb[3];
    char A, B,C;
    h_check_flag_Pr=0;
    error_flag_Pr=0;
    i_count_Pr=0;
    fillScr_1(217,217,217);             //(VGA_PURPLE);
    setColor(VGA_BLACK);               // Set colour to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
//    draw_battery();                   // RESTORE IT IF SPI TO 25Q10 WORK
//    draw_Plug_bat();                  // If plugged to USB 
    setFont(SmallFont);         // SmallFont_8x12  // <------ 
//    print("-",430, 10,0);                   // RESTORE IT IF SPI TO 25Q10 WORK
//    print("-",435, 10,0);
//    print("-",442, 10,0);
//    print("%",449, 10,0);
    setColor(VGA_RED);                  // Set color to all Draw, Fill and Print(letters)
    fillRect(0,296,480,319);
    setColor(VGA_WHITE);                // Set color to all Draw, Fill and Print(letters)
    setBackColor(VGA_RED);  
    setFont(arial_8x16);                //Arial_round_16x24);         // Back to Arial 16X24 // <------     
    print("                                             BACK(F4)", 2, 302, 0); // Hor,Vert,Rotate

    setColor(VGA_BLACK);               // Set color to all Draw, Fill and Print(letters)
    setBackColor_1(217,217,217);  
    setFont(Arial_round_16x24);   
   print("Enter ", 7, 25, 0);          // Hor,Vert,Rotate Enter Channel to set (1~6)
   drawLine(0,49, 479,49); 
   // print("->", 22, 123, 0); //         
//    draw_battery(); 
    
    while(true)                                     // Enter Parameters
        {
            
            print("Enter ID", 22, 149, 0); //  
            x_pos_Pr=350;
            y_pos_Pr=149;  
            i_count_Pr=0;
            while(true)                                                                     // Wait for ANY key
                { 
                delay_ms(keyb_sens); 
                if ((key_int == 62) ||(key_int ==27))                                                  
            {                
                // Go to HOME
           activation_screen();        // To show Screen it HAS to be cleared in every Page
            return;
            }
//                draw_battery();
                if (i_count_Pr >= 8)
                    {
                    h_check_flag_Pr=1;
                    }
                else
                    {
                    h_check_flag_Pr=0;  
                    }
                if ((key_int >= 0x30)&& (key_int <= 0x39)&& (h_check_flag_Pr==0))              //  
                    {
                    printChar(key_int, x_pos_Pr,y_pos_Pr);
                    x_pos_Pr +=16; 
                    Pr_chars[i_count_Pr]=key_int;
                    i_count_Pr++; 
                    if (i_count_Pr >= 8)                               // If more than 3 characters entered
                        {
                        h_check_flag_Pr=1;
                        error_flag_Pr=1;
                        break;
                        }
                    delay_ms(100);        
                    }
                if ((key_int == 108))                                                       // BackSpace 
                    {
                    if (i_count_Pr >0)
                        {
                        x_pos_Pr -=16; 
                        printChar(0x20, x_pos_Pr,y_pos_Pr);
                        i_count_Pr--;
                        }  
                    }
                if ((key_int == 0x0A))
                    {      
                    break;  
                    }   
                }

// END entering
// 52632123            
            if ((Pr_chars[0]==0x35) && (Pr_chars[1]==0x32)&& (Pr_chars[2]==0x36)&& (Pr_chars[3]==0x33)&& (Pr_chars[4]==0x32)&& (Pr_chars[5]==0x31)&& (Pr_chars[6]==0x32)&& (Pr_chars[7]==0x33))
                {
                    print("active                       ", 22, 149, 0); // 
                    Frq_limit=60000;
                   while(true)                                     // Enter Parameters
        {
        delay_ms(keyb_sens); 

// F4 HOME goto home            
        if ((key_int == 62) ||(key_int ==27))                                                  
            {                
                // Go to HOME
            activation_screen();        // To show Screen it HAS to be cleared in every Page
           return;
            }  
                }
            }
            else 
                 activation_Set();
                return;
               
            
            //    return;            
           
            
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 End of File
 */

